// @tiptap/core@2.11.7 downloaded from https://ga.jspm.io/npm:@tiptap/core@2.11.7/dist/index.js

import{Plugin as t,PluginKey as e,TextSelection as n,Selection as o,AllSelection as s,NodeSelection as r,EditorState as i}from"@tiptap/pm/state";import{EditorView as a}from"@tiptap/pm/view";import{keymap as c}from"@tiptap/pm/keymap";import{Schema as l,DOMSerializer as d,Fragment as u,Node as p,DOMParser as m,Slice as h}from"@tiptap/pm/model";import{liftTarget as f,ReplaceStep as g,ReplaceAroundStep as y,joinPoint as v,Transform as x,canSplit as b,canJoin as k,findWrapping as E}from"@tiptap/pm/transform";import{createParagraphNear as M,deleteSelection as w,exitCode as S,joinUp as O,joinDown as T,joinBackward as N,joinForward as C,joinTextblockBackward as R,joinTextblockForward as P,lift as A,liftEmptyBlock as F,newlineInCode as I,selectNodeBackward as j,selectNodeForward as $,selectParentNode as B,selectTextblockEnd as D,selectTextblockStart as L,setBlockType as z,wrapIn as H}from"@tiptap/pm/commands";import{liftListItem as V,sinkListItem as U,wrapInList as J}from"@tiptap/pm/schema-list";
/**
 * Takes a Transaction & Editor State and turns it into a chainable state object
 * @param config The transaction and state to create the chainable state from
 * @returns A chainable Editor state object
 */function createChainableState(t){const{state:e,transaction:n}=t;let{selection:o}=n;let{doc:s}=n;let{storedMarks:r}=n;return{...e,apply:e.apply.bind(e),applyTransaction:e.applyTransaction.bind(e),plugins:e.plugins,schema:e.schema,reconfigure:e.reconfigure.bind(e),toJSON:e.toJSON.bind(e),get storedMarks(){return r},get selection(){return o},get doc(){return s},get tr(){o=n.selection;s=n.doc;r=n.storedMarks;return n}}}class CommandManager{constructor(t){this.editor=t.editor;this.rawCommands=this.editor.extensionManager.commands;this.customState=t.state}get hasCustomState(){return!!this.customState}get state(){return this.customState||this.editor.state}get commands(){const{rawCommands:t,editor:e,state:n}=this;const{view:o}=e;const{tr:s}=n;const r=this.buildProps(s);return Object.fromEntries(Object.entries(t).map((([t,e])=>{const method=(...t)=>{const n=e(...t)(r);s.getMeta("preventDispatch")||this.hasCustomState||o.dispatch(s);return n};return[t,method]})))}get chain(){return()=>this.createChain()}get can(){return()=>this.createCan()}createChain(t,e=true){const{rawCommands:n,editor:o,state:s}=this;const{view:r}=o;const i=[];const a=!!t;const c=t||s.tr;const run=()=>{a||!e||c.getMeta("preventDispatch")||this.hasCustomState||r.dispatch(c);return i.every((t=>t===true))};const l={...Object.fromEntries(Object.entries(n).map((([t,n])=>{const chainedCommand=(...t)=>{const o=this.buildProps(c,e);const s=n(...t)(o);i.push(s);return l};return[t,chainedCommand]}))),run:run};return l}createCan(t){const{rawCommands:e,state:n}=this;const o=false;const s=t||n.tr;const r=this.buildProps(s,o);const i=Object.fromEntries(Object.entries(e).map((([t,e])=>[t,(...t)=>e(...t)({...r,dispatch:void 0})])));return{...i,chain:()=>this.createChain(s,o)}}buildProps(t,e=true){const{rawCommands:n,editor:o,state:s}=this;const{view:r}=o;const i={tr:t,editor:o,view:r,state:createChainableState({state:s,transaction:t}),dispatch:e?()=>{}:void 0,chain:()=>this.createChain(t,e),can:()=>this.createCan(t),get commands(){return Object.fromEntries(Object.entries(n).map((([t,e])=>[t,(...t)=>e(...t)(i)])))}};return i}}class EventEmitter{constructor(){this.callbacks={}}on(t,e){this.callbacks[t]||(this.callbacks[t]=[]);this.callbacks[t].push(e);return this}emit(t,...e){const n=this.callbacks[t];n&&n.forEach((t=>t.apply(this,e)));return this}off(t,e){const n=this.callbacks[t];n&&(e?this.callbacks[t]=n.filter((t=>t!==e)):delete this.callbacks[t]);return this}once(t,e){const onceFn=(...n)=>{this.off(t,onceFn);e.apply(this,n)};return this.on(t,onceFn)}removeAllListeners(){this.callbacks={}}}
/**
 * Returns a field from an extension
 * @param extension The Tiptap extension
 * @param field The field, for example `renderHTML` or `priority`
 * @param context The context object that should be passed as `this` into the function
 * @returns The field value
 */function getExtensionField(t,e,n){if(t.config[e]===void 0&&t.parent)return getExtensionField(t.parent,e,n);if(typeof t.config[e]==="function"){const o=t.config[e].bind({...n,parent:t.parent?getExtensionField(t.parent,e,n):null});return o}return t.config[e]}function splitExtensions(t){const e=t.filter((t=>t.type==="extension"));const n=t.filter((t=>t.type==="node"));const o=t.filter((t=>t.type==="mark"));return{baseExtensions:e,nodeExtensions:n,markExtensions:o}}
/**
 * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.
 * @param extensions List of extensions
 */function getAttributesFromExtensions(t){const e=[];const{nodeExtensions:n,markExtensions:o}=splitExtensions(t);const s=[...n,...o];const r={default:null,rendered:true,renderHTML:null,parseHTML:null,keepOnSplit:true,isRequired:false};t.forEach((t=>{const n={name:t.name,options:t.options,storage:t.storage,extensions:s};const o=getExtensionField(t,"addGlobalAttributes",n);if(!o)return;const i=o();i.forEach((t=>{t.types.forEach((n=>{Object.entries(t.attributes).forEach((([t,o])=>{e.push({type:n,name:t,attribute:{...r,...o}})}))}))}))}));s.forEach((t=>{const n={name:t.name,options:t.options,storage:t.storage};const o=getExtensionField(t,"addAttributes",n);if(!o)return;const s=o();Object.entries(s).forEach((([n,o])=>{const s={...r,...o};typeof(s===null||s===void 0?void 0:s.default)==="function"&&(s.default=s.default());(s===null||s===void 0?void 0:s.isRequired)&&(s===null||s===void 0?void 0:s.default)===void 0&&delete s.default;e.push({type:t.name,name:n,attribute:s})}))}));return e}function getNodeType(t,e){if(typeof t==="string"){if(!e.nodes[t])throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);return e.nodes[t]}return t}function mergeAttributes(...t){return t.filter((t=>!!t)).reduce(((t,e)=>{const n={...t};Object.entries(e).forEach((([t,e])=>{const o=n[t];if(o)if(t==="class"){const o=e?String(e).split(" "):[];const s=n[t]?n[t].split(" "):[];const r=o.filter((t=>!s.includes(t)));n[t]=[...s,...r].join(" ")}else if(t==="style"){const o=e?e.split(";").map((t=>t.trim())).filter(Boolean):[];const s=n[t]?n[t].split(";").map((t=>t.trim())).filter(Boolean):[];const r=new Map;s.forEach((t=>{const[e,n]=t.split(":").map((t=>t.trim()));r.set(e,n)}));o.forEach((t=>{const[e,n]=t.split(":").map((t=>t.trim()));r.set(e,n)}));n[t]=Array.from(r.entries()).map((([t,e])=>`${t}: ${e}`)).join("; ")}else n[t]=e;else n[t]=e}));return n}),{})}function getRenderedAttributes(t,e){return e.filter((e=>e.type===t.type.name)).filter((t=>t.attribute.rendered)).map((e=>e.attribute.renderHTML?e.attribute.renderHTML(t.attrs)||{}:{[e.name]:t.attrs[e.name]})).reduce(((t,e)=>mergeAttributes(t,e)),{})}function isFunction(t){return typeof t==="function"}
/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */function callOrReturn(t,e=void 0,...n){return isFunction(t)?e?t.bind(e)(...n):t(...n):t}function isEmptyObject(t={}){return Object.keys(t).length===0&&t.constructor===Object}function fromString(t){return typeof t!=="string"?t:t.match(/^[+-]?(?:\d*\.)?\d+$/)?Number(t):t==="true"||t!=="false"&&t}
/**
 * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).
 * Cancels when `getAttrs` returned `false`.
 * @param parseRule ProseMirror ParseRule
 * @param extensionAttributes List of attributes to inject
 */function injectExtensionAttributesToParseRule(t,e){return"style"in t?t:{...t,getAttrs:n=>{const o=t.getAttrs?t.getAttrs(n):t.attrs;if(o===false)return false;const s=e.reduce(((t,e)=>{const o=e.attribute.parseHTML?e.attribute.parseHTML(n):fromString(n.getAttribute(e.name));return o===null||o===void 0?t:{...t,[e.name]:o}}),{});return{...o,...s}}}}function cleanUpSchemaItem(t){return Object.fromEntries(Object.entries(t).filter((([t,e])=>(t!=="attrs"||!isEmptyObject(e))&&(e!==null&&e!==void 0))))}
/**
 * Creates a new Prosemirror schema based on the given extensions.
 * @param extensions An array of Tiptap extensions
 * @param editor The editor instance
 * @returns A Prosemirror schema
 */function getSchemaByResolvedExtensions(t,e){var n;const o=getAttributesFromExtensions(t);const{nodeExtensions:s,markExtensions:r}=splitExtensions(t);const i=(n=s.find((t=>getExtensionField(t,"topNode"))))===null||n===void 0?void 0:n.name;const a=Object.fromEntries(s.map((n=>{const s=o.filter((t=>t.type===n.name));const r={name:n.name,options:n.options,storage:n.storage,editor:e};const i=t.reduce(((t,e)=>{const o=getExtensionField(e,"extendNodeSchema",r);return{...t,...o?o(n):{}}}),{});const a=cleanUpSchemaItem({...i,content:callOrReturn(getExtensionField(n,"content",r)),marks:callOrReturn(getExtensionField(n,"marks",r)),group:callOrReturn(getExtensionField(n,"group",r)),inline:callOrReturn(getExtensionField(n,"inline",r)),atom:callOrReturn(getExtensionField(n,"atom",r)),selectable:callOrReturn(getExtensionField(n,"selectable",r)),draggable:callOrReturn(getExtensionField(n,"draggable",r)),code:callOrReturn(getExtensionField(n,"code",r)),whitespace:callOrReturn(getExtensionField(n,"whitespace",r)),linebreakReplacement:callOrReturn(getExtensionField(n,"linebreakReplacement",r)),defining:callOrReturn(getExtensionField(n,"defining",r)),isolating:callOrReturn(getExtensionField(n,"isolating",r)),attrs:Object.fromEntries(s.map((t=>{var e;return[t.name,{default:(e=t===null||t===void 0?void 0:t.attribute)===null||e===void 0?void 0:e.default}]})))});const c=callOrReturn(getExtensionField(n,"parseHTML",r));c&&(a.parseDOM=c.map((t=>injectExtensionAttributesToParseRule(t,s))));const l=getExtensionField(n,"renderHTML",r);l&&(a.toDOM=t=>l({node:t,HTMLAttributes:getRenderedAttributes(t,s)}));const d=getExtensionField(n,"renderText",r);d&&(a.toText=d);return[n.name,a]})));const c=Object.fromEntries(r.map((n=>{const s=o.filter((t=>t.type===n.name));const r={name:n.name,options:n.options,storage:n.storage,editor:e};const i=t.reduce(((t,e)=>{const o=getExtensionField(e,"extendMarkSchema",r);return{...t,...o?o(n):{}}}),{});const a=cleanUpSchemaItem({...i,inclusive:callOrReturn(getExtensionField(n,"inclusive",r)),excludes:callOrReturn(getExtensionField(n,"excludes",r)),group:callOrReturn(getExtensionField(n,"group",r)),spanning:callOrReturn(getExtensionField(n,"spanning",r)),code:callOrReturn(getExtensionField(n,"code",r)),attrs:Object.fromEntries(s.map((t=>{var e;return[t.name,{default:(e=t===null||t===void 0?void 0:t.attribute)===null||e===void 0?void 0:e.default}]})))});const c=callOrReturn(getExtensionField(n,"parseHTML",r));c&&(a.parseDOM=c.map((t=>injectExtensionAttributesToParseRule(t,s))));const l=getExtensionField(n,"renderHTML",r);l&&(a.toDOM=t=>l({mark:t,HTMLAttributes:getRenderedAttributes(t,s)}));return[n.name,a]})));return new l({topNode:i,nodes:a,marks:c})}
/**
 * Tries to get a node or mark type by its name.
 * @param name The name of the node or mark type
 * @param schema The Prosemiror schema to search in
 * @returns The node or mark type, or null if it doesn't exist
 */function getSchemaTypeByName(t,e){return e.nodes[t]||e.marks[t]||null}function isExtensionRulesEnabled(t,e){return Array.isArray(e)?e.some((e=>{const n=typeof e==="string"?e:e.name;return n===t.name})):e}function getHTMLFromFragment(t,e){const n=d.fromSchema(e).serializeFragment(t);const o=document.implementation.createHTMLDocument();const s=o.createElement("div");s.appendChild(n);return s.innerHTML}
/**
 * Returns the text content of a resolved prosemirror position
 * @param $from The resolved position to get the text content from
 * @param maxMatch The maximum number of characters to match
 * @returns The text content
 */const getTextContentFromNodes=(t,e=500)=>{let n="";const o=t.parentOffset;t.parent.nodesBetween(Math.max(0,o-e),o,((t,e,s,r)=>{var i,a;const c=((a=(i=t.type.spec).toText)===null||a===void 0?void 0:a.call(i,{node:t,pos:e,parent:s,index:r}))||t.textContent||"%leaf%";n+=t.isAtom&&!t.isText?c:c.slice(0,Math.max(0,o-e))}));return n};function isRegExp(t){return Object.prototype.toString.call(t)==="[object RegExp]"}class InputRule{constructor(t){this.find=t.find;this.handler=t.handler}}const inputRuleMatcherHandler=(t,e)=>{if(isRegExp(e))return e.exec(t);const n=e(t);if(!n)return null;const o=[n.text];o.index=n.index;o.input=t;o.data=n.data;if(n.replaceWith){n.text.includes(n.replaceWith)||console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');o.push(n.replaceWith)}return o};function run$1(t){var e;const{editor:n,from:o,to:s,text:r,rules:i,plugin:a}=t;const{view:c}=n;if(c.composing)return false;const l=c.state.doc.resolve(o);if(l.parent.type.spec.code||!!((e=l.nodeBefore||l.nodeAfter)===null||e===void 0?void 0:e.marks.find((t=>t.type.spec.code))))return false;let d=false;const u=getTextContentFromNodes(l)+r;i.forEach((t=>{if(d)return;const e=inputRuleMatcherHandler(u,t.find);if(!e)return;const i=c.state.tr;const l=createChainableState({state:c.state,transaction:i});const p={from:o-(e[0].length-r.length),to:s};const{commands:m,chain:h,can:f}=new CommandManager({editor:n,state:l});const g=t.handler({state:l,range:p,match:e,commands:m,chain:h,can:f});if(g!==null&&i.steps.length){i.setMeta(a,{transform:i,from:o,to:s,text:r});c.dispatch(i);d=true}}));return d}function inputRulesPlugin(e){const{editor:n,rules:o}=e;const s=new t({state:{init(){return null},apply(t,e,r){const i=t.getMeta(s);if(i)return i;const a=t.getMeta("applyInputRules");const c=!!a;c&&setTimeout((()=>{let{text:t}=a;typeof t==="string"?t:t=getHTMLFromFragment(u.from(t),r.schema);const{from:e}=a;const i=e+t.length;run$1({editor:n,from:e,to:i,text:t,rules:o,plugin:s})}));return t.selectionSet||t.docChanged?null:e}},props:{handleTextInput(t,e,r,i){return run$1({editor:n,from:e,to:r,text:i,rules:o,plugin:s})},handleDOMEvents:{compositionend:t=>{setTimeout((()=>{const{$cursor:e}=t.state.selection;e&&run$1({editor:n,from:e.pos,to:e.pos,text:"",rules:o,plugin:s})}));return false}},handleKeyDown(t,e){if(e.key!=="Enter")return false;const{$cursor:r}=t.state.selection;return!!r&&run$1({editor:n,from:r.pos,to:r.pos,text:"\n",rules:o,plugin:s})}},isInputRules:true});return s}function getType(t){return Object.prototype.toString.call(t).slice(8,-1)}function isPlainObject(t){return getType(t)==="Object"&&(t.constructor===Object&&Object.getPrototypeOf(t)===Object.prototype)}function mergeDeep(t,e){const n={...t};isPlainObject(t)&&isPlainObject(e)&&Object.keys(e).forEach((o=>{isPlainObject(e[o])&&isPlainObject(t[o])?n[o]=mergeDeep(t[o],e[o]):n[o]=e[o]}));return n}class Mark{constructor(t={}){this.type="mark";this.name="mark";this.parent=null;this.child=null;this.config={name:this.name,defaultOptions:{}};this.config={...this.config,...t};this.name=this.config.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);this.options=this.config.defaultOptions;this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name})));this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(t={}){return new Mark(t)}configure(t={}){const e=this.extend({...this.config,addOptions:()=>mergeDeep(this.options,t)});e.name=this.name;e.parent=this.parent;return e}extend(t={}){const e=new Mark(t);e.parent=this;this.child=e;e.name=t.name?t.name:e.parent.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${e.name}".`);e.options=callOrReturn(getExtensionField(e,"addOptions",{name:e.name}));e.storage=callOrReturn(getExtensionField(e,"addStorage",{name:e.name,options:e.options}));return e}static handleExit({editor:t,mark:e}){const{tr:n}=t.state;const o=t.state.selection.$from;const s=o.pos===o.end();if(s){const s=o.marks();const r=!!s.find((t=>(t===null||t===void 0?void 0:t.type.name)===e.name));if(!r)return false;const i=s.find((t=>(t===null||t===void 0?void 0:t.type.name)===e.name));i&&n.removeStoredMark(i);n.insertText(" ",o.pos);t.view.dispatch(n);return true}return false}}function isNumber(t){return typeof t==="number"}class PasteRule{constructor(t){this.find=t.find;this.handler=t.handler}}const pasteRuleMatcherHandler=(t,e,n)=>{if(isRegExp(e))return[...t.matchAll(e)];const o=e(t,n);return o?o.map((e=>{const n=[e.text];n.index=e.index;n.input=t;n.data=e.data;if(e.replaceWith){e.text.includes(e.replaceWith)||console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');n.push(e.replaceWith)}return n})):[]};function run(t){const{editor:e,state:n,from:o,to:s,rule:r,pasteEvent:i,dropEvent:a}=t;const{commands:c,chain:l,can:d}=new CommandManager({editor:e,state:n});const u=[];n.doc.nodesBetween(o,s,((t,e)=>{if(!t.isTextblock||t.type.spec.code)return;const p=Math.max(o,e);const m=Math.min(s,e+t.content.size);const h=t.textBetween(p-e,m-e,void 0,"￼");const f=pasteRuleMatcherHandler(h,r.find,i);f.forEach((t=>{if(t.index===void 0)return;const e=p+t.index+1;const o=e+t[0].length;const s={from:n.tr.mapping.map(e),to:n.tr.mapping.map(o)};const m=r.handler({state:n,range:s,match:t,commands:c,chain:l,can:d,pasteEvent:i,dropEvent:a});u.push(m)}))}));const p=u.every((t=>t!==null));return p}let W=null;const createClipboardPasteEvent=t=>{var e;const n=new ClipboardEvent("paste",{clipboardData:new DataTransfer});(e=n.clipboardData)===null||e===void 0?void 0:e.setData("text/html",t);return n};function pasteRulesPlugin(e){const{editor:n,rules:o}=e;let s=null;let r=false;let i=false;let a=typeof ClipboardEvent!=="undefined"?new ClipboardEvent("paste"):null;let c;try{c=typeof DragEvent!=="undefined"?new DragEvent("drop"):null}catch{c=null}const processEvent=({state:t,from:e,to:o,rule:s,pasteEvt:r})=>{const i=t.tr;const l=createChainableState({state:t,transaction:i});const d=run({editor:n,state:l,from:Math.max(e-1,0),to:o.b-1,rule:s,pasteEvent:r,dropEvent:c});if(d&&i.steps.length){try{c=typeof DragEvent!=="undefined"?new DragEvent("drop"):null}catch{c=null}a=typeof ClipboardEvent!=="undefined"?new ClipboardEvent("paste"):null;return i}};const l=o.map((e=>new t({view(t){const handleDragstart=e=>{var o;s=((o=t.dom.parentElement)===null||o===void 0?void 0:o.contains(e.target))?t.dom.parentElement:null;s&&(W=n)};const handleDragend=()=>{W&&(W=null)};window.addEventListener("dragstart",handleDragstart);window.addEventListener("dragend",handleDragend);return{destroy(){window.removeEventListener("dragstart",handleDragstart);window.removeEventListener("dragend",handleDragend)}}},props:{handleDOMEvents:{drop:(t,e)=>{i=s===t.dom.parentElement;c=e;if(!i){const t=W;t&&setTimeout((()=>{const e=t.state.selection;e&&t.commands.deleteRange({from:e.from,to:e.to})}),10)}return false},paste:(t,e)=>{var n;const o=(n=e.clipboardData)===null||n===void 0?void 0:n.getData("text/html");a=e;r=!!(o===null||o===void 0?void 0:o.includes("data-pm-slice"));return false}}},appendTransaction:(t,n,o)=>{const s=t[0];const c=s.getMeta("uiEvent")==="paste"&&!r;const l=s.getMeta("uiEvent")==="drop"&&!i;const d=s.getMeta("applyPasteRules");const p=!!d;if(!c&&!l&&!p)return;if(p){let{text:t}=d;typeof t==="string"?t:t=getHTMLFromFragment(u.from(t),o.schema);const{from:n}=d;const s=n+t.length;const r=createClipboardPasteEvent(t);return processEvent({rule:e,state:o,from:n,to:{b:s},pasteEvt:r})}const m=n.doc.content.findDiffStart(o.doc.content);const h=n.doc.content.findDiffEnd(o.doc.content);return isNumber(m)&&h&&m!==h.b?processEvent({rule:e,state:o,from:m,to:h,pasteEvt:a}):void 0}})));return l}function findDuplicates(t){const e=t.filter(((e,n)=>t.indexOf(e)!==n));return Array.from(new Set(e))}class ExtensionManager{constructor(t,e){this.splittableMarks=[];this.editor=e;this.extensions=ExtensionManager.resolve(t);this.schema=getSchemaByResolvedExtensions(this.extensions,e);this.setupExtensions()}
/**
     * Returns a flattened and sorted extension list while
     * also checking for duplicated extensions and warns the user.
     * @param extensions An array of Tiptap extensions
     * @returns An flattened and sorted array of Tiptap extensions
     */static resolve(t){const e=ExtensionManager.sort(ExtensionManager.flatten(t));const n=findDuplicates(e.map((t=>t.name)));n.length&&console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((t=>`'${t}'`)).join(", ")}]. This can lead to issues.`);return e}
/**
     * Create a flattened array of extensions by traversing the `addExtensions` field.
     * @param extensions An array of Tiptap extensions
     * @returns A flattened array of Tiptap extensions
     */static flatten(t){return t.map((t=>{const e={name:t.name,options:t.options,storage:t.storage};const n=getExtensionField(t,"addExtensions",e);return n?[t,...this.flatten(n())]:t})).flat(10)}
/**
     * Sort extensions by priority.
     * @param extensions An array of Tiptap extensions
     * @returns A sorted array of Tiptap extensions by priority
     */static sort(t){const e=100;return t.sort(((t,n)=>{const o=getExtensionField(t,"priority")||e;const s=getExtensionField(n,"priority")||e;return o>s?-1:o<s?1:0}))}
/**
     * Get all commands from the extensions.
     * @returns An object with all commands where the key is the command name and the value is the command function
     */get commands(){return this.extensions.reduce(((t,e)=>{const n={name:e.name,options:e.options,storage:e.storage,editor:this.editor,type:getSchemaTypeByName(e.name,this.schema)};const o=getExtensionField(e,"addCommands",n);return o?{...t,...o()}:t}),{})}
/**
     * Get all registered Prosemirror plugins from the extensions.
     * @returns An array of Prosemirror plugins
     */get plugins(){const{editor:t}=this;const e=ExtensionManager.sort([...this.extensions].reverse());const n=[];const o=[];const s=e.map((e=>{const s={name:e.name,options:e.options,storage:e.storage,editor:t,type:getSchemaTypeByName(e.name,this.schema)};const r=[];const i=getExtensionField(e,"addKeyboardShortcuts",s);let a={};e.type==="mark"&&getExtensionField(e,"exitable",s)&&(a.ArrowRight=()=>Mark.handleExit({editor:t,mark:e}));if(i){const e=Object.fromEntries(Object.entries(i()).map((([e,n])=>[e,()=>n({editor:t})])));a={...a,...e}}const l=c(a);r.push(l);const d=getExtensionField(e,"addInputRules",s);isExtensionRulesEnabled(e,t.options.enableInputRules)&&d&&n.push(...d());const u=getExtensionField(e,"addPasteRules",s);isExtensionRulesEnabled(e,t.options.enablePasteRules)&&u&&o.push(...u());const p=getExtensionField(e,"addProseMirrorPlugins",s);if(p){const t=p();r.push(...t)}return r})).flat();return[inputRulesPlugin({editor:t,rules:n}),...pasteRulesPlugin({editor:t,rules:o}),...s]}
/**
     * Get all attributes from the extensions.
     * @returns An array of attributes
     */get attributes(){return getAttributesFromExtensions(this.extensions)}
/**
     * Get all node views from the extensions.
     * @returns An object with all node views where the key is the node name and the value is the node view function
     */get nodeViews(){const{editor:t}=this;const{nodeExtensions:e}=splitExtensions(this.extensions);return Object.fromEntries(e.filter((t=>!!getExtensionField(t,"addNodeView"))).map((e=>{const n=this.attributes.filter((t=>t.type===e.name));const o={name:e.name,options:e.options,storage:e.storage,editor:t,type:getNodeType(e.name,this.schema)};const s=getExtensionField(e,"addNodeView",o);if(!s)return[];const nodeview=(o,r,i,a,c)=>{const l=getRenderedAttributes(o,n);return s()({node:o,view:r,getPos:i,decorations:a,innerDecorations:c,editor:t,extension:e,HTMLAttributes:l})};return[e.name,nodeview]})))}setupExtensions(){this.extensions.forEach((t=>{var e;this.editor.extensionStorage[t.name]=t.storage;const n={name:t.name,options:t.options,storage:t.storage,editor:this.editor,type:getSchemaTypeByName(t.name,this.schema)};if(t.type==="mark"){const o=(e=callOrReturn(getExtensionField(t,"keepOnSplit",n)))===null||e===void 0||e;o&&this.splittableMarks.push(t.name)}const o=getExtensionField(t,"onBeforeCreate",n);const s=getExtensionField(t,"onCreate",n);const r=getExtensionField(t,"onUpdate",n);const i=getExtensionField(t,"onSelectionUpdate",n);const a=getExtensionField(t,"onTransaction",n);const c=getExtensionField(t,"onFocus",n);const l=getExtensionField(t,"onBlur",n);const d=getExtensionField(t,"onDestroy",n);o&&this.editor.on("beforeCreate",o);s&&this.editor.on("create",s);r&&this.editor.on("update",r);i&&this.editor.on("selectionUpdate",i);a&&this.editor.on("transaction",a);c&&this.editor.on("focus",c);l&&this.editor.on("blur",l);d&&this.editor.on("destroy",d)}))}}class Extension{constructor(t={}){this.type="extension";this.name="extension";this.parent=null;this.child=null;this.config={name:this.name,defaultOptions:{}};this.config={...this.config,...t};this.name=this.config.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);this.options=this.config.defaultOptions;this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name})));this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(t={}){return new Extension(t)}configure(t={}){const e=this.extend({...this.config,addOptions:()=>mergeDeep(this.options,t)});e.name=this.name;e.parent=this.parent;return e}extend(t={}){const e=new Extension({...this.config,...t});e.parent=this;this.child=e;e.name=t.name?t.name:e.parent.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${e.name}".`);e.options=callOrReturn(getExtensionField(e,"addOptions",{name:e.name}));e.storage=callOrReturn(getExtensionField(e,"addStorage",{name:e.name,options:e.options}));return e}}
/**
 * Gets the text between two positions in a Prosemirror node
 * and serializes it using the given text serializers and block separator (see getText)
 * @param startNode The Prosemirror node to start from
 * @param range The range of the text to get
 * @param options Options for the text serializer & block separator
 * @returns The text between the two positions
 */function getTextBetween(t,e,n){const{from:o,to:s}=e;const{blockSeparator:r="\n\n",textSerializers:i={}}=n||{};let a="";t.nodesBetween(o,s,((t,n,c,l)=>{var d;t.isBlock&&n>o&&(a+=r);const u=i===null||i===void 0?void 0:i[t.type.name];if(u){c&&(a+=u({node:t,pos:n,parent:c,index:l,range:e}));return false}t.isText&&(a+=(d=t===null||t===void 0?void 0:t.text)===null||d===void 0?void 0:d.slice(Math.max(o,n)-n,s-n))}));return a}
/**
 * Find text serializers `toText` in a Prosemirror schema
 * @param schema The Prosemirror schema to search in
 * @returns A record of text serializers by node name
 */function getTextSerializersFromSchema(t){return Object.fromEntries(Object.entries(t.nodes).filter((([,t])=>t.spec.toText)).map((([t,e])=>[t,e.spec.toText])))}const _=Extension.create({name:"clipboardTextSerializer",addOptions(){return{blockSeparator:void 0}},addProseMirrorPlugins(){return[new t({key:new e("clipboardTextSerializer"),props:{clipboardTextSerializer:()=>{const{editor:t}=this;const{state:e,schema:n}=t;const{doc:o,selection:s}=e;const{ranges:r}=s;const i=Math.min(...r.map((t=>t.$from.pos)));const a=Math.max(...r.map((t=>t.$to.pos)));const c=getTextSerializersFromSchema(n);const l={from:i,to:a};return getTextBetween(o,l,{...this.options.blockSeparator!==void 0?{blockSeparator:this.options.blockSeparator}:{},textSerializers:c})}}})]}});const blur=()=>({editor:t,view:e})=>{requestAnimationFrame((()=>{var n;if(!t.isDestroyed){e.dom.blur();(n=window===null||window===void 0?void 0:window.getSelection())===null||n===void 0?void 0:n.removeAllRanges()}}));return true};const clearContent=(t=false)=>({commands:e})=>e.setContent("",t);const clearNodes=()=>({state:t,tr:e,dispatch:n})=>{const{selection:o}=e;const{ranges:s}=o;if(!n)return true;s.forEach((({$from:n,$to:o})=>{t.doc.nodesBetween(n.pos,o.pos,((t,n)=>{if(t.type.isText)return;const{doc:o,mapping:s}=e;const r=o.resolve(s.map(n));const i=o.resolve(s.map(n+t.nodeSize));const a=r.blockRange(i);if(!a)return;const c=f(a);if(t.type.isTextblock){const{defaultType:t}=r.parent.contentMatchAt(r.index());e.setNodeMarkup(a.start,t)}(c||c===0)&&e.lift(a,c)}))}));return true};const command=t=>e=>t(e);const createParagraphNear=()=>({state:t,dispatch:e})=>M(t,e);const cut=(t,e)=>({editor:o,tr:s})=>{const{state:r}=o;const i=r.doc.slice(t.from,t.to);s.deleteRange(t.from,t.to);const a=s.mapping.map(e);s.insert(a,i.content);s.setSelection(new n(s.doc.resolve(a-1)));return true};const deleteCurrentNode=()=>({tr:t,dispatch:e})=>{const{selection:n}=t;const o=n.$anchor.node();if(o.content.size>0)return false;const s=t.selection.$anchor;for(let n=s.depth;n>0;n-=1){const r=s.node(n);if(r.type===o.type){if(e){const e=s.before(n);const o=s.after(n);t.delete(e,o).scrollIntoView()}return true}}return false};const deleteNode=t=>({tr:e,state:n,dispatch:o})=>{const s=getNodeType(t,n.schema);const r=e.selection.$anchor;for(let t=r.depth;t>0;t-=1){const n=r.node(t);if(n.type===s){if(o){const n=r.before(t);const o=r.after(t);e.delete(n,o).scrollIntoView()}return true}}return false};const deleteRange=t=>({tr:e,dispatch:n})=>{const{from:o,to:s}=t;n&&e.delete(o,s);return true};const deleteSelection=()=>({state:t,dispatch:e})=>w(t,e);const enter=()=>({commands:t})=>t.keyboardShortcut("Enter");const exitCode=()=>({state:t,dispatch:e})=>S(t,e)
/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */;function objectIncludes(t,e,n={strict:true}){const o=Object.keys(e);return!o.length||o.every((o=>n.strict?e[o]===t[o]:isRegExp(e[o])?e[o].test(t[o]):e[o]===t[o]))}function findMarkInSet(t,e,n={}){return t.find((t=>t.type===e&&objectIncludes(Object.fromEntries(Object.keys(n).map((e=>[e,t.attrs[e]]))),n)))}function isMarkInSet(t,e,n={}){return!!findMarkInSet(t,e,n)}function getMarkRange(t,e,n){var o;if(!t||!e)return;let s=t.parent.childAfter(t.parentOffset);s.node&&s.node.marks.some((t=>t.type===e))||(s=t.parent.childBefore(t.parentOffset));if(!s.node||!s.node.marks.some((t=>t.type===e)))return;n=n||((o=s.node.marks[0])===null||o===void 0?void 0:o.attrs);const r=findMarkInSet([...s.node.marks],e,n);if(!r)return;let i=s.index;let a=t.start()+s.offset;let c=i+1;let l=a+s.node.nodeSize;while(i>0&&isMarkInSet([...t.parent.child(i-1).marks],e,n)){i-=1;a-=t.parent.child(i).nodeSize}while(c<t.parent.childCount&&isMarkInSet([...t.parent.child(c).marks],e,n)){l+=t.parent.child(c).nodeSize;c+=1}return{from:a,to:l}}function getMarkType(t,e){if(typeof t==="string"){if(!e.marks[t])throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);return e.marks[t]}return t}const extendMarkRange=(t,e={})=>({tr:o,state:s,dispatch:r})=>{const i=getMarkType(t,s.schema);const{doc:a,selection:c}=o;const{$from:l,from:d,to:u}=c;if(r){const t=getMarkRange(l,i,e);if(t&&t.from<=d&&t.to>=u){const e=n.create(a,t.from,t.to);o.setSelection(e)}}return true};const first=t=>e=>{const n=typeof t==="function"?t(e):t;for(let t=0;t<n.length;t+=1)if(n[t](e))return true;return false};function isTextSelection(t){return t instanceof n}function minMax(t=0,e=0,n=0){return Math.min(Math.max(t,e),n)}function resolveFocusPosition(t,e=null){if(!e)return null;const s=o.atStart(t);const r=o.atEnd(t);if(e==="start"||e===true)return s;if(e==="end")return r;const i=s.from;const a=r.to;return e==="all"?n.create(t,minMax(0,i,a),minMax(t.content.size,i,a)):n.create(t,minMax(e,i,a),minMax(e,i,a))}function isAndroid(){return navigator.platform==="Android"||/android/i.test(navigator.userAgent)}function isiOS(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document}const focus=(t=null,e={})=>({editor:n,view:o,tr:s,dispatch:r})=>{e={scrollIntoView:true,...e};const delayedFocus=()=>{(isiOS()||isAndroid())&&o.dom.focus();requestAnimationFrame((()=>{if(!n.isDestroyed){o.focus();(e===null||e===void 0?void 0:e.scrollIntoView)&&n.commands.scrollIntoView()}}))};if(o.hasFocus()&&t===null||t===false)return true;if(r&&t===null&&!isTextSelection(n.state.selection)){delayedFocus();return true}const i=resolveFocusPosition(s.doc,t)||n.state.selection;const a=n.state.selection.eq(i);if(r){a||s.setSelection(i);a&&s.storedMarks&&s.setStoredMarks(s.storedMarks);delayedFocus()}return true};const forEach=(t,e)=>n=>t.every(((t,o)=>e(t,{...n,index:o})));const insertContent=(t,e)=>({tr:n,commands:o})=>o.insertContentAt({from:n.selection.from,to:n.selection.to},t,e);const removeWhitespaces=t=>{const e=t.childNodes;for(let n=e.length-1;n>=0;n-=1){const o=e[n];o.nodeType===3&&o.nodeValue&&/^(\n\s\s|\n)$/.test(o.nodeValue)?t.removeChild(o):o.nodeType===1&&removeWhitespaces(o)}return t};function elementFromString(t){const e=`<body>${t}</body>`;const n=(new window.DOMParser).parseFromString(e,"text/html").body;return removeWhitespaces(n)}
/**
 * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.
 * @param content The JSON or HTML content to create the node from
 * @param schema The Prosemirror schema to use for the node
 * @param options Options for the parser
 * @returns The created Prosemirror node or fragment
 */function createNodeFromContent(t,e,n){if(t instanceof p||t instanceof u)return t;n={slice:true,parseOptions:{},...n};const o=typeof t==="object"&&t!==null;const s=typeof t==="string";if(o)try{const o=Array.isArray(t)&&t.length>0;if(o)return u.fromArray(t.map((t=>e.nodeFromJSON(t))));const s=e.nodeFromJSON(t);n.errorOnInvalidContent&&s.check();return s}catch(o){if(n.errorOnInvalidContent)throw new Error("[tiptap error]: Invalid JSON content",{cause:o});console.warn("[tiptap warn]: Invalid content.","Passed value:",t,"Error:",o);return createNodeFromContent("",e,n)}if(s){if(n.errorOnInvalidContent){let o=false;let s="";const r=new l({topNode:e.spec.topNode,marks:e.spec.marks,nodes:e.spec.nodes.append({__tiptap__private__unknown__catch__all__node:{content:"inline*",group:"block",parseDOM:[{tag:"*",getAttrs:t=>{o=true;s=typeof t==="string"?t:t.outerHTML;return null}}]}})});n.slice?m.fromSchema(r).parseSlice(elementFromString(t),n.parseOptions):m.fromSchema(r).parse(elementFromString(t),n.parseOptions);if(n.errorOnInvalidContent&&o)throw new Error("[tiptap error]: Invalid HTML content",{cause:new Error(`Invalid element found: ${s}`)})}const o=m.fromSchema(e);return n.slice?o.parseSlice(elementFromString(t),n.parseOptions).content:o.parse(elementFromString(t),n.parseOptions)}return createNodeFromContent("",e,n)}function selectionToInsertionEnd(t,e,n){const s=t.steps.length-1;if(s<e)return;const r=t.steps[s];if(!(r instanceof g||r instanceof y))return;const i=t.mapping.maps[s];let a=0;i.forEach(((t,e,n,o)=>{a===0&&(a=o)}));t.setSelection(o.near(t.doc.resolve(a),n))}const isFragment=t=>!("type"in t);const insertContentAt=(t,e,n)=>({tr:o,dispatch:s,editor:r})=>{var i;if(s){n={parseOptions:r.options.parseOptions,updateSelection:true,applyInputRules:false,applyPasteRules:false,...n};let s;try{s=createNodeFromContent(e,r.schema,{parseOptions:{preserveWhitespace:"full",...n.parseOptions},errorOnInvalidContent:(i=n.errorOnInvalidContent)!==null&&i!==void 0?i:r.options.enableContentCheck})}catch(t){r.emit("contentError",{editor:r,error:t,disableCollaboration:()=>{r.storage.collaboration&&(r.storage.collaboration.isDisabled=true)}});return false}let{from:a,to:c}=typeof t==="number"?{from:t,to:t}:{from:t.from,to:t.to};let l=true;let d=true;const p=isFragment(s)?s:[s];p.forEach((t=>{t.check();l=!!l&&(t.isText&&t.marks.length===0);d=!!d&&t.isBlock}));if(a===c&&d){const{parent:t}=o.doc.resolve(a);const e=t.isTextblock&&!t.type.spec.code&&!t.childCount;if(e){a-=1;c+=1}}let m;if(l){if(Array.isArray(e))m=e.map((t=>t.text||"")).join("");else if(e instanceof u){let t="";e.forEach((e=>{e.text&&(t+=e.text)}));m=t}else m=typeof e==="object"&&e&&e.text?e.text:e;o.insertText(m,a,c)}else{m=s;o.replaceWith(a,c,m)}n.updateSelection&&selectionToInsertionEnd(o,o.steps.length-1,-1);n.applyInputRules&&o.setMeta("applyInputRules",{from:a,text:m});n.applyPasteRules&&o.setMeta("applyPasteRules",{from:a,text:m})}return true};const joinUp=()=>({state:t,dispatch:e})=>O(t,e);const joinDown=()=>({state:t,dispatch:e})=>T(t,e);const joinBackward=()=>({state:t,dispatch:e})=>N(t,e);const joinForward=()=>({state:t,dispatch:e})=>C(t,e);const joinItemBackward=()=>({state:t,dispatch:e,tr:n})=>{try{const o=v(t.doc,t.selection.$from.pos,-1);if(o===null||o===void 0)return false;n.join(o,2);e&&e(n);return true}catch{return false}};const joinItemForward=()=>({state:t,dispatch:e,tr:n})=>{try{const o=v(t.doc,t.selection.$from.pos,1);if(o===null||o===void 0)return false;n.join(o,2);e&&e(n);return true}catch{return false}};const joinTextblockBackward=()=>({state:t,dispatch:e})=>R(t,e);const joinTextblockForward=()=>({state:t,dispatch:e})=>P(t,e);function isMacOS(){return typeof navigator!=="undefined"&&/Mac/.test(navigator.platform)}function normalizeKeyName(t){const e=t.split(/-(?!$)/);let n=e[e.length-1];n==="Space"&&(n=" ");let o;let s;let r;let i;for(let t=0;t<e.length-1;t+=1){const n=e[t];if(/^(cmd|meta|m)$/i.test(n))i=true;else if(/^a(lt)?$/i.test(n))o=true;else if(/^(c|ctrl|control)$/i.test(n))s=true;else if(/^s(hift)?$/i.test(n))r=true;else{if(!/^mod$/i.test(n))throw new Error(`Unrecognized modifier name: ${n}`);isiOS()||isMacOS()?i=true:s=true}}o&&(n=`Alt-${n}`);s&&(n=`Ctrl-${n}`);i&&(n=`Meta-${n}`);r&&(n=`Shift-${n}`);return n}const keyboardShortcut=t=>({editor:e,view:n,tr:o,dispatch:s})=>{const r=normalizeKeyName(t).split(/-(?!$)/);const i=r.find((t=>!["Alt","Ctrl","Meta","Shift"].includes(t)));const a=new KeyboardEvent("keydown",{key:i==="Space"?" ":i,altKey:r.includes("Alt"),ctrlKey:r.includes("Ctrl"),metaKey:r.includes("Meta"),shiftKey:r.includes("Shift"),bubbles:true,cancelable:true});const c=e.captureTransaction((()=>{n.someProp("handleKeyDown",(t=>t(n,a)))}));c===null||c===void 0?void 0:c.steps.forEach((t=>{const e=t.map(o.mapping);e&&s&&o.maybeStep(e)}));return true};function isNodeActive(t,e,n={}){const{from:o,to:s,empty:r}=t.selection;const i=e?getNodeType(e,t.schema):null;const a=[];t.doc.nodesBetween(o,s,((t,e)=>{if(t.isText)return;const n=Math.max(o,e);const r=Math.min(s,e+t.nodeSize);a.push({node:t,from:n,to:r})}));const c=s-o;const l=a.filter((t=>!i||i.name===t.node.type.name)).filter((t=>objectIncludes(t.node.attrs,n,{strict:false})));if(r)return!!l.length;const d=l.reduce(((t,e)=>t+e.to-e.from),0);return d>=c}const lift=(t,e={})=>({state:n,dispatch:o})=>{const s=getNodeType(t,n.schema);const r=isNodeActive(n,s,e);return!!r&&A(n,o)};const liftEmptyBlock=()=>({state:t,dispatch:e})=>F(t,e);const liftListItem=t=>({state:e,dispatch:n})=>{const o=getNodeType(t,e.schema);return V(o)(e,n)};const newlineInCode=()=>({state:t,dispatch:e})=>I(t,e)
/**
 * Get the type of a schema item by its name.
 * @param name The name of the schema item
 * @param schema The Prosemiror schema to search in
 * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist
 */;function getSchemaTypeNameByName(t,e){return e.nodes[t]?"node":e.marks[t]?"mark":null}
/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */function deleteProps(t,e){const n=typeof e==="string"?[e]:e;return Object.keys(t).reduce(((e,o)=>{n.includes(o)||(e[o]=t[o]);return e}),{})}const resetAttributes=(t,e)=>({tr:n,state:o,dispatch:s})=>{let r=null;let i=null;const a=getSchemaTypeNameByName(typeof t==="string"?t:t.name,o.schema);if(!a)return false;a==="node"&&(r=getNodeType(t,o.schema));a==="mark"&&(i=getMarkType(t,o.schema));s&&n.selection.ranges.forEach((t=>{o.doc.nodesBetween(t.$from.pos,t.$to.pos,((t,o)=>{r&&r===t.type&&n.setNodeMarkup(o,void 0,deleteProps(t.attrs,e));i&&t.marks.length&&t.marks.forEach((s=>{i===s.type&&n.addMark(o,o+t.nodeSize,i.create(deleteProps(s.attrs,e)))}))}))}));return true};const scrollIntoView=()=>({tr:t,dispatch:e})=>{e&&t.scrollIntoView();return true};const selectAll=()=>({tr:t,dispatch:e})=>{if(e){const e=new s(t.doc);t.setSelection(e)}return true};const selectNodeBackward=()=>({state:t,dispatch:e})=>j(t,e);const selectNodeForward=()=>({state:t,dispatch:e})=>$(t,e);const selectParentNode=()=>({state:t,dispatch:e})=>B(t,e);const selectTextblockEnd=()=>({state:t,dispatch:e})=>D(t,e);const selectTextblockStart=()=>({state:t,dispatch:e})=>L(t,e)
/**
 * Create a new Prosemirror document node from content.
 * @param content The JSON or HTML content to create the document from
 * @param schema The Prosemirror schema to use for the document
 * @param parseOptions Options for the parser
 * @returns The created Prosemirror document node
 */;function createDocument(t,e,n={},o={}){return createNodeFromContent(t,e,{slice:false,parseOptions:n,errorOnInvalidContent:o.errorOnInvalidContent})}const setContent=(t,e=false,n={},o={})=>({editor:s,tr:r,dispatch:i,commands:a})=>{var c,l;const{doc:d}=r;if(n.preserveWhitespace!=="full"){const a=createDocument(t,s.schema,n,{errorOnInvalidContent:(c=o.errorOnInvalidContent)!==null&&c!==void 0?c:s.options.enableContentCheck});i&&r.replaceWith(0,d.content.size,a).setMeta("preventUpdate",!e);return true}i&&r.setMeta("preventUpdate",!e);return a.insertContentAt({from:0,to:d.content.size},t,{parseOptions:n,errorOnInvalidContent:(l=o.errorOnInvalidContent)!==null&&l!==void 0?l:s.options.enableContentCheck})};function getMarkAttributes(t,e){const n=getMarkType(e,t.schema);const{from:o,to:s,empty:r}=t.selection;const i=[];if(r){t.storedMarks&&i.push(...t.storedMarks);i.push(...t.selection.$head.marks())}else t.doc.nodesBetween(o,s,(t=>{i.push(...t.marks)}));const a=i.find((t=>t.type.name===n.name));return a?{...a.attrs}:{}}
/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 * @param oldDoc The Prosemirror node to start from
 * @param transactions The transactions to combine
 * @returns A new `Transform` with all steps of the passed transactions
 */function combineTransactionSteps(t,e){const n=new x(t);e.forEach((t=>{t.steps.forEach((t=>{n.step(t)}))}));return n}
/**
 * Gets the default block type at a given match
 * @param match The content match to get the default block type from
 * @returns The default block type or null
 */function defaultBlockAt(t){for(let e=0;e<t.edgeCount;e+=1){const{type:n}=t.edge(e);if(n.isTextblock&&!n.hasRequiredAttrs())return n}return null}
/**
 * Find children inside a Prosemirror node that match a predicate.
 * @param node The Prosemirror node to search in
 * @param predicate The predicate to match
 * @returns An array of nodes with their positions
 */function findChildren(t,e){const n=[];t.descendants(((t,o)=>{e(t)&&n.push({node:t,pos:o})}));return n}
/**
 * Same as `findChildren` but searches only within a `range`.
 * @param node The Prosemirror node to search in
 * @param range The range to search in
 * @param predicate The predicate to match
 * @returns An array of nodes with their positions
 */function findChildrenInRange(t,e,n){const o=[];t.nodesBetween(e.from,e.to,((t,e)=>{n(t)&&o.push({node:t,pos:e})}));return o}
/**
 * Finds the closest parent node to a resolved position that matches a predicate.
 * @param $pos The resolved position to search from
 * @param predicate The predicate to match
 * @returns The closest parent node to the resolved position that matches the predicate
 * @example ```js
 * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')
 * ```
 */function findParentNodeClosestToPos(t,e){for(let n=t.depth;n>0;n-=1){const o=t.node(n);if(e(o))return{pos:n>0?t.before(n):0,start:t.start(n),depth:n,node:o}}}
/**
 * Finds the closest parent node to the current selection that matches a predicate.
 * @param predicate The predicate to match
 * @returns A command that finds the closest parent node to the current selection that matches the predicate
 * @example ```js
 * findParentNode(node => node.type.name === 'paragraph')
 * ```
 */function findParentNode(t){return e=>findParentNodeClosestToPos(e.$from,t)}function getSchema(t,e){const n=ExtensionManager.resolve(t);return getSchemaByResolvedExtensions(n,e)}
/**
 * Generate HTML from a JSONContent
 * @param doc The JSONContent to generate HTML from
 * @param extensions The extensions to use for the schema
 * @returns The generated HTML
 */function generateHTML(t,e){const n=getSchema(e);const o=p.fromJSON(n,t);return getHTMLFromFragment(o.content,n)}
/**
 * Generate JSONContent from HTML
 * @param html The HTML to generate JSONContent from
 * @param extensions The extensions to use for the schema
 * @returns The generated JSONContent
 */function generateJSON(t,e){const n=getSchema(e);const o=elementFromString(t);return m.fromSchema(n).parse(o).toJSON()}
/**
 * Gets the text of a Prosemirror node
 * @param node The Prosemirror node
 * @param options Options for the text serializer & block separator
 * @returns The text of the node
 * @example ```js
 * const text = getText(node, { blockSeparator: '\n' })
 * ```
 */function getText(t,e){const n={from:0,to:t.content.size};return getTextBetween(t,n,e)}
/**
 * Generate raw text from a JSONContent
 * @param doc The JSONContent to generate text from
 * @param extensions The extensions to use for the schema
 * @param options Options for the text generation f.e. blockSeparator or textSerializers
 * @returns The generated text
 */function generateText(t,e,n){const{blockSeparator:o="\n\n",textSerializers:s={}}=n||{};const r=getSchema(e);const i=p.fromJSON(r,t);return getText(i,{blockSeparator:o,textSerializers:{...getTextSerializersFromSchema(r),...s}})}function getNodeAttributes(t,e){const n=getNodeType(e,t.schema);const{from:o,to:s}=t.selection;const r=[];t.doc.nodesBetween(o,s,(t=>{r.push(t)}));const i=r.reverse().find((t=>t.type.name===n.name));return i?{...i.attrs}:{}}
/**
 * Get node or mark attributes by type or name on the current editor state
 * @param state The current editor state
 * @param typeOrName The node or mark type or name
 * @returns The attributes of the node or mark or an empty object
 */function getAttributes(t,e){const n=getSchemaTypeNameByName(typeof e==="string"?e:e.name,t.schema);return n==="node"?getNodeAttributes(t,e):n==="mark"?getMarkAttributes(t,e):{}}function removeDuplicates(t,e=JSON.stringify){const n={};return t.filter((t=>{const o=e(t);return!Object.prototype.hasOwnProperty.call(n,o)&&(n[o]=true)}))}function simplifyChangedRanges(t){const e=removeDuplicates(t);return e.length===1?e:e.filter(((t,n)=>{const o=e.filter(((t,e)=>e!==n));return!o.some((e=>t.oldRange.from>=e.oldRange.from&&t.oldRange.to<=e.oldRange.to&&t.newRange.from>=e.newRange.from&&t.newRange.to<=e.newRange.to))}))}function getChangedRanges(t){const{mapping:e,steps:n}=t;const o=[];e.maps.forEach(((t,s)=>{const r=[];if(t.ranges.length)t.forEach(((t,e)=>{r.push({from:t,to:e})}));else{const{from:t,to:e}=n[s];if(t===void 0||e===void 0)return;r.push({from:t,to:e})}r.forEach((({from:t,to:n})=>{const r=e.slice(s).map(t,-1);const i=e.slice(s).map(n);const a=e.invert().map(r,-1);const c=e.invert().map(i);o.push({oldRange:{from:a,to:c},newRange:{from:r,to:i}})}))}));return simplifyChangedRanges(o)}function getDebugJSON(t,e=0){const n=t.type===t.type.schema.topNodeType;const o=n?0:1;const s=e;const r=s+t.nodeSize;const i=t.marks.map((t=>{const e={type:t.type.name};Object.keys(t.attrs).length&&(e.attrs={...t.attrs});return e}));const a={...t.attrs};const c={type:t.type.name,from:s,to:r};Object.keys(a).length&&(c.attrs=a);i.length&&(c.marks=i);if(t.content.childCount){c.content=[];t.forEach(((t,n)=>{var s;(s=c.content)===null||s===void 0?void 0:s.push(getDebugJSON(t,e+n+o))}))}t.text&&(c.text=t.text);return c}function getMarksBetween(t,e,n){const o=[];t===e?n.resolve(t).marks().forEach((e=>{const s=n.resolve(t);const r=getMarkRange(s,e.type);r&&o.push({mark:e,...r})})):n.nodesBetween(t,e,((t,e)=>{t&&(t===null||t===void 0?void 0:t.nodeSize)!==void 0&&o.push(...t.marks.map((n=>({from:e,to:e+t.nodeSize,mark:n}))))}));return o}
/**
 * Finds the first node of a given type or name in the current selection.
 * @param state The editor state.
 * @param typeOrName The node type or name.
 * @param pos The position to start searching from.
 * @param maxDepth The maximum depth to search.
 * @returns The node and the depth as an array.
 */const getNodeAtPosition=(t,e,n,o=20)=>{const s=t.doc.resolve(n);let r=o;let i=null;while(r>0&&i===null){const t=s.node(r);(t===null||t===void 0?void 0:t.type.name)===e?i=t:r-=1}return[i,r]};
/**
 * Return attributes of an extension that should be splitted by keepOnSplit flag
 * @param extensionAttributes Array of extension attributes
 * @param typeName The type of the extension
 * @param attributes The attributes of the extension
 * @returns The splitted attributes
 */function getSplittedAttributes(t,e,n){return Object.fromEntries(Object.entries(n).filter((([n])=>{const o=t.find((t=>t.type===e&&t.name===n));return!!o&&o.attribute.keepOnSplit})))}function isMarkActive(t,e,n={}){const{empty:o,ranges:s}=t.selection;const r=e?getMarkType(e,t.schema):null;if(o)return!!(t.storedMarks||t.selection.$from.marks()).filter((t=>!r||r.name===t.type.name)).find((t=>objectIncludes(t.attrs,n,{strict:false})));let i=0;const a=[];s.forEach((({$from:e,$to:n})=>{const o=e.pos;const s=n.pos;t.doc.nodesBetween(o,s,((t,e)=>{if(!t.isText&&!t.marks.length)return;const n=Math.max(o,e);const r=Math.min(s,e+t.nodeSize);const c=r-n;i+=c;a.push(...t.marks.map((t=>({mark:t,from:n,to:r}))))}))}));if(i===0)return false;const c=a.filter((t=>!r||r.name===t.mark.type.name)).filter((t=>objectIncludes(t.mark.attrs,n,{strict:false}))).reduce(((t,e)=>t+e.to-e.from),0);const l=a.filter((t=>!r||t.mark.type!==r&&t.mark.type.excludes(r))).reduce(((t,e)=>t+e.to-e.from),0);const d=c>0?c+l:c;return d>=i}function isActive(t,e,n={}){if(!e)return isNodeActive(t,null,n)||isMarkActive(t,null,n);const o=getSchemaTypeNameByName(e,t.schema);return o==="node"?isNodeActive(t,e,n):o==="mark"&&isMarkActive(t,e,n)}const isAtEndOfNode=(t,e)=>{const{$from:n,$to:o,$anchor:s}=t.selection;if(e){const n=findParentNode((t=>t.type.name===e))(t.selection);if(!n)return false;const o=t.doc.resolve(n.pos+1);return s.pos+1===o.end()}return!(o.parentOffset<o.parent.nodeSize-2||n.pos!==o.pos)};const isAtStartOfNode=t=>{const{$from:e,$to:n}=t.selection;return!(e.parentOffset>0||e.pos!==n.pos)};function isList(t,e){const{nodeExtensions:n}=splitExtensions(e);const o=n.find((e=>e.name===t));if(!o)return false;const s={name:o.name,options:o.options,storage:o.storage};const r=callOrReturn(getExtensionField(o,"group",s));return typeof r==="string"&&r.split(" ").includes("list")}function isNodeEmpty(t,{checkChildren:e=true,ignoreWhitespace:n=false}={}){var o;if(n){if(t.type.name==="hardBreak")return true;if(t.isText)return/^\s*$/m.test((o=t.text)!==null&&o!==void 0?o:"")}if(t.isText)return!t.text;if(t.isAtom||t.isLeaf)return false;if(t.content.childCount===0)return true;if(e){let o=true;t.content.forEach((t=>{o!==false&&(isNodeEmpty(t,{ignoreWhitespace:n,checkChildren:e})||(o=false))}));return o}return false}function isNodeSelection(t){return t instanceof r}function posToDOMRect(t,e,n){const o=0;const s=t.state.doc.content.size;const r=minMax(e,o,s);const i=minMax(n,o,s);const a=t.coordsAtPos(r);const c=t.coordsAtPos(i,-1);const l=Math.min(a.top,c.top);const d=Math.max(a.bottom,c.bottom);const u=Math.min(a.left,c.left);const p=Math.max(a.right,c.right);const m=p-u;const h=d-l;const f=u;const g=l;const y={top:l,bottom:d,left:u,right:p,width:m,height:h,x:f,y:g};return{...y,toJSON:()=>y}}function rewriteUnknownContentInner({json:t,validMarks:e,validNodes:n,options:o,rewrittenContent:s=[]}){t.marks&&Array.isArray(t.marks)&&(t.marks=t.marks.filter((t=>{const n=typeof t==="string"?t:t.type;if(e.has(n))return true;s.push({original:JSON.parse(JSON.stringify(t)),unsupported:n});return false})));t.content&&Array.isArray(t.content)&&(t.content=t.content.map((t=>rewriteUnknownContentInner({json:t,validMarks:e,validNodes:n,options:o,rewrittenContent:s}).json)).filter((t=>t!==null&&t!==void 0)));if(t.type&&!n.has(t.type)){s.push({original:JSON.parse(JSON.stringify(t)),unsupported:t.type});if(t.content&&Array.isArray(t.content)&&(o===null||o===void 0?void 0:o.fallbackToParagraph)!==false){t.type="paragraph";return{json:t,rewrittenContent:s}}return{json:null,rewrittenContent:s}}return{json:t,rewrittenContent:s}}function rewriteUnknownContent(t,e,n){return rewriteUnknownContentInner({json:t,validNodes:new Set(Object.keys(e.nodes)),validMarks:new Set(Object.keys(e.marks)),options:n})}function canSetMark(t,e,n){var o;const{selection:s}=e;let r=null;isTextSelection(s)&&(r=s.$cursor);if(r){const e=(o=t.storedMarks)!==null&&o!==void 0?o:r.marks();return!!n.isInSet(e)||!e.some((t=>t.type.excludes(n)))}const{ranges:i}=s;return i.some((({$from:e,$to:o})=>{let s=e.depth===0&&(t.doc.inlineContent&&t.doc.type.allowsMarkType(n));t.doc.nodesBetween(e.pos,o.pos,((t,e,o)=>{if(s)return false;if(t.isInline){const e=!o||o.type.allowsMarkType(n);const r=!!n.isInSet(t.marks)||!t.marks.some((t=>t.type.excludes(n)));s=e&&r}return!s}));return s}))}const setMark=(t,e={})=>({tr:n,state:o,dispatch:s})=>{const{selection:r}=n;const{empty:i,ranges:a}=r;const c=getMarkType(t,o.schema);if(s)if(i){const t=getMarkAttributes(o,c);n.addStoredMark(c.create({...t,...e}))}else a.forEach((t=>{const s=t.$from.pos;const r=t.$to.pos;o.doc.nodesBetween(s,r,((t,o)=>{const i=Math.max(o,s);const a=Math.min(o+t.nodeSize,r);const l=t.marks.find((t=>t.type===c));l?t.marks.forEach((t=>{c===t.type&&n.addMark(i,a,c.create({...t.attrs,...e}))})):n.addMark(i,a,c.create(e))}))}));return canSetMark(o,n,c)};const setMeta=(t,e)=>({tr:n})=>{n.setMeta(t,e);return true};const setNode=(t,e={})=>({state:n,dispatch:o,chain:s})=>{const r=getNodeType(t,n.schema);let i;n.selection.$anchor.sameParent(n.selection.$head)&&(i=n.selection.$anchor.parent.attrs);if(!r.isTextblock){console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');return false}return s().command((({commands:t})=>{const o=z(r,{...i,...e})(n);return!!o||t.clearNodes()})).command((({state:t})=>z(r,{...i,...e})(t,o))).run()};const setNodeSelection=t=>({tr:e,dispatch:n})=>{if(n){const{doc:n}=e;const o=minMax(t,0,n.content.size);const s=r.create(n,o);e.setSelection(s)}return true};const setTextSelection=t=>({tr:e,dispatch:o})=>{if(o){const{doc:o}=e;const{from:s,to:r}=typeof t==="number"?{from:t,to:t}:t;const i=n.atStart(o).from;const a=n.atEnd(o).to;const c=minMax(s,i,a);const l=minMax(r,i,a);const d=n.create(o,c,l);e.setSelection(d)}return true};const sinkListItem=t=>({state:e,dispatch:n})=>{const o=getNodeType(t,e.schema);return U(o)(e,n)};function ensureMarks(t,e){const n=t.storedMarks||t.selection.$to.parentOffset&&t.selection.$from.marks();if(n){const o=n.filter((t=>e===null||e===void 0?void 0:e.includes(t.type.name)));t.tr.ensureMarks(o)}}const splitBlock=({keepMarks:t=true}={})=>({tr:e,state:o,dispatch:s,editor:i})=>{const{selection:a,doc:c}=e;const{$from:l,$to:d}=a;const u=i.extensionManager.attributes;const p=getSplittedAttributes(u,l.node().type.name,l.node().attrs);if(a instanceof r&&a.node.isBlock){if(!l.parentOffset||!b(c,l.pos))return false;if(s){t&&ensureMarks(o,i.extensionManager.splittableMarks);e.split(l.pos).scrollIntoView()}return true}if(!l.parent.isBlock)return false;const m=d.parentOffset===d.parent.content.size;const h=l.depth===0?void 0:defaultBlockAt(l.node(-1).contentMatchAt(l.indexAfter(-1)));let f=m&&h?[{type:h,attrs:p}]:void 0;let g=b(e.doc,e.mapping.map(l.pos),1,f);if(!f&&!g&&b(e.doc,e.mapping.map(l.pos),1,h?[{type:h}]:void 0)){g=true;f=h?[{type:h,attrs:p}]:void 0}if(s){if(g){a instanceof n&&e.deleteSelection();e.split(e.mapping.map(l.pos),1,f);if(h&&!m&&!l.parentOffset&&l.parent.type!==h){const t=e.mapping.map(l.before());const n=e.doc.resolve(t);l.node(-1).canReplaceWith(n.index(),n.index()+1,h)&&e.setNodeMarkup(e.mapping.map(l.before()),h)}}t&&ensureMarks(o,i.extensionManager.splittableMarks);e.scrollIntoView()}return g};const splitListItem=(t,e={})=>({tr:o,state:s,dispatch:r,editor:i})=>{var a;const c=getNodeType(t,s.schema);const{$from:l,$to:d}=s.selection;const p=s.selection.node;if(p&&p.isBlock||l.depth<2||!l.sameParent(d))return false;const m=l.node(-1);if(m.type!==c)return false;const f=i.extensionManager.attributes;if(l.parent.content.size===0&&l.node(-1).childCount===l.indexAfter(-1)){if(l.depth===2||l.node(-3).type!==c||l.index(-2)!==l.node(-2).childCount-1)return false;if(r){let t=u.empty;const s=l.index(-1)?1:l.index(-2)?2:3;for(let e=l.depth-s;e>=l.depth-3;e-=1)t=u.from(l.node(e).copy(t));const r=l.indexAfter(-1)<l.node(-2).childCount?1:l.indexAfter(-2)<l.node(-3).childCount?2:3;const i={...getSplittedAttributes(f,l.node().type.name,l.node().attrs),...e};const d=((a=c.contentMatch.defaultType)===null||a===void 0?void 0:a.createAndFill(i))||void 0;t=t.append(u.from(c.createAndFill(null,d)||void 0));const p=l.before(l.depth-(s-1));o.replace(p,l.after(-r),new h(t,4-s,0));let m=-1;o.doc.nodesBetween(p,o.doc.content.size,((t,e)=>{if(m>-1)return false;t.isTextblock&&t.content.size===0&&(m=e+1)}));m>-1&&o.setSelection(n.near(o.doc.resolve(m)));o.scrollIntoView()}return true}const g=d.pos===l.end()?m.contentMatchAt(0).defaultType:null;const y={...getSplittedAttributes(f,m.type.name,m.attrs),...e};const v={...getSplittedAttributes(f,l.node().type.name,l.node().attrs),...e};o.delete(l.pos,d.pos);const x=g?[{type:c,attrs:y},{type:g,attrs:v}]:[{type:c,attrs:y}];if(!b(o.doc,l.pos,2))return false;if(r){const{selection:t,storedMarks:e}=s;const{splittableMarks:n}=i.extensionManager;const a=e||t.$to.parentOffset&&t.$from.marks();o.split(l.pos,2,x).scrollIntoView();if(!a||!r)return true;const c=a.filter((t=>n.includes(t.type.name)));o.ensureMarks(c)}return true};const joinListBackwards=(t,e)=>{const n=findParentNode((t=>t.type===e))(t.selection);if(!n)return true;const o=t.doc.resolve(Math.max(0,n.pos-1)).before(n.depth);if(o===void 0)return true;const s=t.doc.nodeAt(o);const r=n.node.type===(s===null||s===void 0?void 0:s.type)&&k(t.doc,n.pos);if(!r)return true;t.join(n.pos);return true};const joinListForwards=(t,e)=>{const n=findParentNode((t=>t.type===e))(t.selection);if(!n)return true;const o=t.doc.resolve(n.start).after(n.depth);if(o===void 0)return true;const s=t.doc.nodeAt(o);const r=n.node.type===(s===null||s===void 0?void 0:s.type)&&k(t.doc,o);if(!r)return true;t.join(o);return true};const toggleList=(t,e,n,o={})=>({editor:s,tr:r,state:i,dispatch:a,chain:c,commands:l,can:d})=>{const{extensions:u,splittableMarks:p}=s.extensionManager;const m=getNodeType(t,i.schema);const h=getNodeType(e,i.schema);const{selection:f,storedMarks:g}=i;const{$from:y,$to:v}=f;const x=y.blockRange(v);const b=g||f.$to.parentOffset&&f.$from.marks();if(!x)return false;const k=findParentNode((t=>isList(t.type.name,u)))(f);if(x.depth>=1&&k&&x.depth-k.depth<=1){if(k.node.type===m)return l.liftListItem(h);if(isList(k.node.type.name,u)&&m.validContent(k.node.content)&&a)return c().command((()=>{r.setNodeMarkup(k.pos,m);return true})).command((()=>joinListBackwards(r,m))).command((()=>joinListForwards(r,m))).run()}return n&&b&&a?c().command((()=>{const t=d().wrapInList(m,o);const e=b.filter((t=>p.includes(t.type.name)));r.ensureMarks(e);return!!t||l.clearNodes()})).wrapInList(m,o).command((()=>joinListBackwards(r,m))).command((()=>joinListForwards(r,m))).run():c().command((()=>{const t=d().wrapInList(m,o);return!!t||l.clearNodes()})).wrapInList(m,o).command((()=>joinListBackwards(r,m))).command((()=>joinListForwards(r,m))).run()};const toggleMark=(t,e={},n={})=>({state:o,commands:s})=>{const{extendEmptyMarkRange:r=false}=n;const i=getMarkType(t,o.schema);const a=isMarkActive(o,i,e);return a?s.unsetMark(i,{extendEmptyMarkRange:r}):s.setMark(i,e)};const toggleNode=(t,e,n={})=>({state:o,commands:s})=>{const r=getNodeType(t,o.schema);const i=getNodeType(e,o.schema);const a=isNodeActive(o,r,n);let c;o.selection.$anchor.sameParent(o.selection.$head)&&(c=o.selection.$anchor.parent.attrs);return a?s.setNode(i,c):s.setNode(r,{...c,...n})};const toggleWrap=(t,e={})=>({state:n,commands:o})=>{const s=getNodeType(t,n.schema);const r=isNodeActive(n,s,e);return r?o.lift(s):o.wrapIn(s,e)};const undoInputRule=()=>({state:t,dispatch:e})=>{const n=t.plugins;for(let o=0;o<n.length;o+=1){const s=n[o];let r;if(s.spec.isInputRules&&(r=s.getState(t))){if(e){const e=t.tr;const n=r.transform;for(let t=n.steps.length-1;t>=0;t-=1)e.step(n.steps[t].invert(n.docs[t]));if(r.text){const n=e.doc.resolve(r.from).marks();e.replaceWith(r.from,r.to,t.schema.text(r.text,n))}else e.delete(r.from,r.to)}return true}}return false};const unsetAllMarks=()=>({tr:t,dispatch:e})=>{const{selection:n}=t;const{empty:o,ranges:s}=n;if(o)return true;e&&s.forEach((e=>{t.removeMark(e.$from.pos,e.$to.pos)}));return true};const unsetMark=(t,e={})=>({tr:n,state:o,dispatch:s})=>{var r;const{extendEmptyMarkRange:i=false}=e;const{selection:a}=n;const c=getMarkType(t,o.schema);const{$from:l,empty:d,ranges:u}=a;if(!s)return true;if(d&&i){let{from:t,to:e}=a;const o=(r=l.marks().find((t=>t.type===c)))===null||r===void 0?void 0:r.attrs;const s=getMarkRange(l,c,o);if(s){t=s.from;e=s.to}n.removeMark(t,e,c)}else u.forEach((t=>{n.removeMark(t.$from.pos,t.$to.pos,c)}));n.removeStoredMark(c);return true};const updateAttributes=(t,e={})=>({tr:n,state:o,dispatch:s})=>{let r=null;let i=null;const a=getSchemaTypeNameByName(typeof t==="string"?t:t.name,o.schema);if(!a)return false;a==="node"&&(r=getNodeType(t,o.schema));a==="mark"&&(i=getMarkType(t,o.schema));s&&n.selection.ranges.forEach((t=>{const s=t.$from.pos;const a=t.$to.pos;let c;let l;let d;let u;n.selection.empty?o.doc.nodesBetween(s,a,((t,e)=>{if(r&&r===t.type){d=Math.max(e,s);u=Math.min(e+t.nodeSize,a);c=e;l=t}})):o.doc.nodesBetween(s,a,((t,o)=>{if(o<s&&r&&r===t.type){d=Math.max(o,s);u=Math.min(o+t.nodeSize,a);c=o;l=t}if(o>=s&&o<=a){r&&r===t.type&&n.setNodeMarkup(o,void 0,{...t.attrs,...e});i&&t.marks.length&&t.marks.forEach((r=>{if(i===r.type){const c=Math.max(o,s);const l=Math.min(o+t.nodeSize,a);n.addMark(c,l,i.create({...r.attrs,...e}))}}))}}));if(l){c!==void 0&&n.setNodeMarkup(c,void 0,{...l.attrs,...e});i&&l.marks.length&&l.marks.forEach((t=>{i===t.type&&n.addMark(d,u,i.create({...t.attrs,...e}))}))}}));return true};const wrapIn=(t,e={})=>({state:n,dispatch:o})=>{const s=getNodeType(t,n.schema);return H(s,e)(n,o)};const wrapInList=(t,e={})=>({state:n,dispatch:o})=>{const s=getNodeType(t,n.schema);return J(s,e)(n,o)};var K=Object.freeze({__proto__:null,blur:blur,clearContent:clearContent,clearNodes:clearNodes,command:command,createParagraphNear:createParagraphNear,cut:cut,deleteCurrentNode:deleteCurrentNode,deleteNode:deleteNode,deleteRange:deleteRange,deleteSelection:deleteSelection,enter:enter,exitCode:exitCode,extendMarkRange:extendMarkRange,first:first,focus:focus,forEach:forEach,insertContent:insertContent,insertContentAt:insertContentAt,joinBackward:joinBackward,joinDown:joinDown,joinForward:joinForward,joinItemBackward:joinItemBackward,joinItemForward:joinItemForward,joinTextblockBackward:joinTextblockBackward,joinTextblockForward:joinTextblockForward,joinUp:joinUp,keyboardShortcut:keyboardShortcut,lift:lift,liftEmptyBlock:liftEmptyBlock,liftListItem:liftListItem,newlineInCode:newlineInCode,resetAttributes:resetAttributes,scrollIntoView:scrollIntoView,selectAll:selectAll,selectNodeBackward:selectNodeBackward,selectNodeForward:selectNodeForward,selectParentNode:selectParentNode,selectTextblockEnd:selectTextblockEnd,selectTextblockStart:selectTextblockStart,setContent:setContent,setMark:setMark,setMeta:setMeta,setNode:setNode,setNodeSelection:setNodeSelection,setTextSelection:setTextSelection,sinkListItem:sinkListItem,splitBlock:splitBlock,splitListItem:splitListItem,toggleList:toggleList,toggleMark:toggleMark,toggleNode:toggleNode,toggleWrap:toggleWrap,undoInputRule:undoInputRule,unsetAllMarks:unsetAllMarks,unsetMark:unsetMark,updateAttributes:updateAttributes,wrapIn:wrapIn,wrapInList:wrapInList});const q=Extension.create({name:"commands",addCommands(){return{...K}}});const G=Extension.create({name:"drop",addProseMirrorPlugins(){return[new t({key:new e("tiptapDrop"),props:{handleDrop:(t,e,n,o)=>{this.editor.emit("drop",{editor:this.editor,event:e,slice:n,moved:o})}}})]}});const X=Extension.create({name:"editable",addProseMirrorPlugins(){return[new t({key:new e("editable"),props:{editable:()=>this.editor.options.editable}})]}});const Y=new e("focusEvents");const Q=Extension.create({name:"focusEvents",addProseMirrorPlugins(){const{editor:e}=this;return[new t({key:Y,props:{handleDOMEvents:{focus:(t,n)=>{e.isFocused=true;const o=e.state.tr.setMeta("focus",{event:n}).setMeta("addToHistory",false);t.dispatch(o);return false},blur:(t,n)=>{e.isFocused=false;const o=e.state.tr.setMeta("blur",{event:n}).setMeta("addToHistory",false);t.dispatch(o);return false}}}})]}});const Z=Extension.create({name:"keymap",addKeyboardShortcuts(){const handleBackspace=()=>this.editor.commands.first((({commands:t})=>[()=>t.undoInputRule(),()=>t.command((({tr:e})=>{const{selection:n,doc:s}=e;const{empty:r,$anchor:i}=n;const{pos:a,parent:c}=i;const l=i.parent.isTextblock&&a>0?e.doc.resolve(a-1):i;const d=l.parent.type.spec.isolating;const u=i.pos-i.parentOffset;const p=d&&l.parent.childCount===1?u===i.pos:o.atStart(s).from===a;return!(!r||!c.type.isTextblock||c.textContent.length||!p||p&&i.parent.type.name==="paragraph")&&t.clearNodes()})),()=>t.deleteSelection(),()=>t.joinBackward(),()=>t.selectNodeBackward()]));const handleDelete=()=>this.editor.commands.first((({commands:t})=>[()=>t.deleteSelection(),()=>t.deleteCurrentNode(),()=>t.joinForward(),()=>t.selectNodeForward()]));const handleEnter=()=>this.editor.commands.first((({commands:t})=>[()=>t.newlineInCode(),()=>t.createParagraphNear(),()=>t.liftEmptyBlock(),()=>t.splitBlock()]));const t={Enter:handleEnter,"Mod-Enter":()=>this.editor.commands.exitCode(),Backspace:handleBackspace,"Mod-Backspace":handleBackspace,"Shift-Backspace":handleBackspace,Delete:handleDelete,"Mod-Delete":handleDelete,"Mod-a":()=>this.editor.commands.selectAll()};const e={...t};const n={...t,"Ctrl-h":handleBackspace,"Alt-Backspace":handleBackspace,"Ctrl-d":handleDelete,"Ctrl-Alt-Backspace":handleDelete,"Alt-Delete":handleDelete,"Alt-d":handleDelete,"Ctrl-a":()=>this.editor.commands.selectTextblockStart(),"Ctrl-e":()=>this.editor.commands.selectTextblockEnd()};return isiOS()||isMacOS()?n:e},addProseMirrorPlugins(){return[new t({key:new e("clearDocument"),appendTransaction:(t,e,n)=>{if(t.some((t=>t.getMeta("composition"))))return;const s=t.some((t=>t.docChanged))&&!e.doc.eq(n.doc);const r=t.some((t=>t.getMeta("preventClearDocument")));if(!s||r)return;const{empty:i,from:a,to:c}=e.selection;const l=o.atStart(e.doc).from;const d=o.atEnd(e.doc).to;const u=a===l&&c===d;if(i||!u)return;const p=isNodeEmpty(n.doc);if(!p)return;const m=n.tr;const h=createChainableState({state:n,transaction:m});const{commands:f}=new CommandManager({editor:this.editor,state:h});f.clearNodes();return m.steps.length?m:void 0}})]}});const tt=Extension.create({name:"paste",addProseMirrorPlugins(){return[new t({key:new e("tiptapPaste"),props:{handlePaste:(t,e,n)=>{this.editor.emit("paste",{editor:this.editor,event:e,slice:n})}}})]}});const et=Extension.create({name:"tabindex",addProseMirrorPlugins(){return[new t({key:new e("tabindex"),props:{attributes:()=>this.editor.isEditable?{tabindex:"0"}:{}}})]}});var nt=Object.freeze({__proto__:null,ClipboardTextSerializer:_,Commands:q,Drop:G,Editable:X,FocusEvents:Q,Keymap:Z,Paste:tt,Tabindex:et,focusEventsPluginKey:Y});class NodePos{get name(){return this.node.type.name}constructor(t,e,n=false,o=null){this.currentNode=null;this.actualDepth=null;this.isBlock=n;this.resolvedPos=t;this.editor=e;this.currentNode=o}get node(){return this.currentNode||this.resolvedPos.node()}get element(){return this.editor.view.domAtPos(this.pos).node}get depth(){var t;return(t=this.actualDepth)!==null&&t!==void 0?t:this.resolvedPos.depth}get pos(){return this.resolvedPos.pos}get content(){return this.node.content}set content(t){let e=this.from;let n=this.to;if(this.isBlock){if(this.content.size===0){console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);return}e=this.from+1;n=this.to-1}this.editor.commands.insertContentAt({from:e,to:n},t)}get attributes(){return this.node.attrs}get textContent(){return this.node.textContent}get size(){return this.node.nodeSize}get from(){return this.isBlock?this.pos:this.resolvedPos.start(this.resolvedPos.depth)}get range(){return{from:this.from,to:this.to}}get to(){return this.isBlock?this.pos+this.size:this.resolvedPos.end(this.resolvedPos.depth)+(this.node.isText?0:1)}get parent(){if(this.depth===0)return null;const t=this.resolvedPos.start(this.resolvedPos.depth-1);const e=this.resolvedPos.doc.resolve(t);return new NodePos(e,this.editor)}get before(){let t=this.resolvedPos.doc.resolve(this.from-(this.isBlock?1:2));t.depth!==this.depth&&(t=this.resolvedPos.doc.resolve(this.from-3));return new NodePos(t,this.editor)}get after(){let t=this.resolvedPos.doc.resolve(this.to+(this.isBlock?2:1));t.depth!==this.depth&&(t=this.resolvedPos.doc.resolve(this.to+3));return new NodePos(t,this.editor)}get children(){const t=[];this.node.content.forEach(((e,n)=>{const o=e.isBlock&&!e.isTextblock;const s=e.isAtom&&!e.isText;const r=this.pos+n+(s?0:1);const i=this.resolvedPos.doc.resolve(r);if(!o&&i.depth<=this.depth)return;const a=new NodePos(i,this.editor,o,o?e:null);o&&(a.actualDepth=this.depth+1);t.push(new NodePos(i,this.editor,o,o?e:null))}));return t}get firstChild(){return this.children[0]||null}get lastChild(){const t=this.children;return t[t.length-1]||null}closest(t,e={}){let n=null;let o=this.parent;while(o&&!n){if(o.node.type.name===t)if(Object.keys(e).length>0){const t=o.node.attrs;const n=Object.keys(e);for(let o=0;o<n.length;o+=1){const s=n[o];if(t[s]!==e[s])break}}else n=o;o=o.parent}return n}querySelector(t,e={}){return this.querySelectorAll(t,e,true)[0]||null}querySelectorAll(t,e={},n=false){let o=[];if(!this.children||this.children.length===0)return o;const s=Object.keys(e);this.children.forEach((r=>{if(!(n&&o.length>0)){if(r.node.type.name===t){const t=s.every((t=>e[t]===r.node.attrs[t]));t&&o.push(r)}n&&o.length>0||(o=o.concat(r.querySelectorAll(t,e,n)))}}));return o}setAttribute(t){const{tr:e}=this.editor.state;e.setNodeMarkup(this.from,void 0,{...this.node.attrs,...t});this.editor.view.dispatch(e)}}const ot='.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}';function createStyleTag(t,e,n){const o=document.querySelector(`style[data-tiptap-style${n?`-${n}`:""}]`);if(o!==null)return o;const s=document.createElement("style");e&&s.setAttribute("nonce",e);s.setAttribute("data-tiptap-style"+(n?`-${n}`:""),"");s.innerHTML=t;document.getElementsByTagName("head")[0].appendChild(s);return s}class Editor extends EventEmitter{constructor(t={}){super();this.isFocused=false;this.isInitialized=false;this.extensionStorage={};this.options={element:document.createElement("div"),content:"",injectCSS:true,injectNonce:void 0,extensions:[],autofocus:false,editable:true,editorProps:{},parseOptions:{},coreExtensionOptions:{},enableInputRules:true,enablePasteRules:true,enableCoreExtensions:true,enableContentCheck:false,onBeforeCreate:()=>null,onCreate:()=>null,onUpdate:()=>null,onSelectionUpdate:()=>null,onTransaction:()=>null,onFocus:()=>null,onBlur:()=>null,onDestroy:()=>null,onContentError:({error:t})=>{throw t},onPaste:()=>null,onDrop:()=>null};this.isCapturingTransaction=false;this.capturedTransaction=null;this.setOptions(t);this.createExtensionManager();this.createCommandManager();this.createSchema();this.on("beforeCreate",this.options.onBeforeCreate);this.emit("beforeCreate",{editor:this});this.on("contentError",this.options.onContentError);this.createView();this.injectCSS();this.on("create",this.options.onCreate);this.on("update",this.options.onUpdate);this.on("selectionUpdate",this.options.onSelectionUpdate);this.on("transaction",this.options.onTransaction);this.on("focus",this.options.onFocus);this.on("blur",this.options.onBlur);this.on("destroy",this.options.onDestroy);this.on("drop",(({event:t,slice:e,moved:n})=>this.options.onDrop(t,e,n)));this.on("paste",(({event:t,slice:e})=>this.options.onPaste(t,e)));window.setTimeout((()=>{if(!this.isDestroyed){this.commands.focus(this.options.autofocus);this.emit("create",{editor:this});this.isInitialized=true}}),0)}get storage(){return this.extensionStorage}get commands(){return this.commandManager.commands}chain(){return this.commandManager.chain()}can(){return this.commandManager.can()}injectCSS(){this.options.injectCSS&&document&&(this.css=createStyleTag(ot,this.options.injectNonce))}
/**
     * Update editor options.
     *
     * @param options A list of options
     */setOptions(t={}){this.options={...this.options,...t};if(this.view&&this.state&&!this.isDestroyed){this.options.editorProps&&this.view.setProps(this.options.editorProps);this.view.updateState(this.state)}}setEditable(t,e=true){this.setOptions({editable:t});e&&this.emit("update",{editor:this,transaction:this.state.tr})}get isEditable(){return this.options.editable&&this.view&&this.view.editable}get state(){return this.view.state}
/**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     * @returns The new editor state
     */registerPlugin(t,e){const n=isFunction(e)?e(t,[...this.state.plugins]):[...this.state.plugins,t];const o=this.state.reconfigure({plugins:n});this.view.updateState(o);return o}
/**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKeyToRemove The plugins name
     * @returns The new editor state or undefined if the editor is destroyed
     */unregisterPlugin(t){if(this.isDestroyed)return;const e=this.state.plugins;let n=e;[].concat(t).forEach((t=>{const o=typeof t==="string"?`${t}$`:t.key;n=e.filter((t=>!t.key.startsWith(o)))}));if(e.length===n.length)return;const o=this.state.reconfigure({plugins:n});this.view.updateState(o);return o}createExtensionManager(){var t,e;const n=this.options.enableCoreExtensions?[X,_.configure({blockSeparator:(e=(t=this.options.coreExtensionOptions)===null||t===void 0?void 0:t.clipboardTextSerializer)===null||e===void 0?void 0:e.blockSeparator}),q,Q,Z,et,G,tt].filter((t=>typeof this.options.enableCoreExtensions!=="object"||this.options.enableCoreExtensions[t.name]!==false)):[];const o=[...n,...this.options.extensions].filter((t=>["extension","node","mark"].includes(t===null||t===void 0?void 0:t.type)));this.extensionManager=new ExtensionManager(o,this)}createCommandManager(){this.commandManager=new CommandManager({editor:this})}createSchema(){this.schema=this.extensionManager.schema}createView(){var t;let e;try{e=createDocument(this.options.content,this.schema,this.options.parseOptions,{errorOnInvalidContent:this.options.enableContentCheck})}catch(t){if(!(t instanceof Error)||!["[tiptap error]: Invalid JSON content","[tiptap error]: Invalid HTML content"].includes(t.message))throw t;this.emit("contentError",{editor:this,error:t,disableCollaboration:()=>{this.storage.collaboration&&(this.storage.collaboration.isDisabled=true);this.options.extensions=this.options.extensions.filter((t=>t.name!=="collaboration"));this.createExtensionManager()}});e=createDocument(this.options.content,this.schema,this.options.parseOptions,{errorOnInvalidContent:false})}const n=resolveFocusPosition(e,this.options.autofocus);this.view=new a(this.options.element,{...this.options.editorProps,attributes:{role:"textbox",...(t=this.options.editorProps)===null||t===void 0?void 0:t.attributes},dispatchTransaction:this.dispatchTransaction.bind(this),state:i.create({doc:e,selection:n||void 0})});const o=this.state.reconfigure({plugins:this.extensionManager.plugins});this.view.updateState(o);this.createNodeViews();this.prependClass();const s=this.view.dom;s.editor=this}createNodeViews(){this.view.isDestroyed||this.view.setProps({nodeViews:this.extensionManager.nodeViews})}prependClass(){this.view.dom.className=`tiptap ${this.view.dom.className}`}captureTransaction(t){this.isCapturingTransaction=true;t();this.isCapturingTransaction=false;const e=this.capturedTransaction;this.capturedTransaction=null;return e}
/**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */dispatchTransaction(t){if(this.view.isDestroyed)return;if(this.isCapturingTransaction){if(!this.capturedTransaction){this.capturedTransaction=t;return}t.steps.forEach((t=>{var e;return(e=this.capturedTransaction)===null||e===void 0?void 0:e.step(t)}));return}const e=this.state.apply(t);const n=!this.state.selection.eq(e.selection);this.emit("beforeTransaction",{editor:this,transaction:t,nextState:e});this.view.updateState(e);this.emit("transaction",{editor:this,transaction:t});n&&this.emit("selectionUpdate",{editor:this,transaction:t});const o=t.getMeta("focus");const s=t.getMeta("blur");o&&this.emit("focus",{editor:this,event:o.event,transaction:t});s&&this.emit("blur",{editor:this,event:s.event,transaction:t});t.docChanged&&!t.getMeta("preventUpdate")&&this.emit("update",{editor:this,transaction:t})}getAttributes(t){return getAttributes(this.state,t)}isActive(t,e){const n=typeof t==="string"?t:null;const o=typeof t==="string"?e:t;return isActive(this.state,n,o)}getJSON(){return this.state.doc.toJSON()}getHTML(){return getHTMLFromFragment(this.state.doc.content,this.schema)}getText(t){const{blockSeparator:e="\n\n",textSerializers:n={}}=t||{};return getText(this.state.doc,{blockSeparator:e,textSerializers:{...getTextSerializersFromSchema(this.schema),...n}})}get isEmpty(){return isNodeEmpty(this.state.doc)}
/**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */getCharacterCount(){console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');return this.state.doc.content.size-2}destroy(){this.emit("destroy");if(this.view){const t=this.view.dom;t&&t.editor&&delete t.editor;this.view.destroy()}this.removeAllListeners()}get isDestroyed(){var t;return!((t=this.view)===null||t===void 0?void 0:t.docView)}$node(t,e){var n;return((n=this.$doc)===null||n===void 0?void 0:n.querySelector(t,e))||null}$nodes(t,e){var n;return((n=this.$doc)===null||n===void 0?void 0:n.querySelectorAll(t,e))||null}$pos(t){const e=this.state.doc.resolve(t);return new NodePos(e,this)}get $doc(){return this.$pos(0)}}function markInputRule(t){return new InputRule({find:t.find,handler:({state:e,range:n,match:o})=>{const s=callOrReturn(t.getAttributes,void 0,o);if(s===false||s===null)return null;const{tr:r}=e;const i=o[o.length-1];const a=o[0];if(i){const o=a.search(/\S/);const c=n.from+a.indexOf(i);const l=c+i.length;const d=getMarksBetween(n.from,n.to,e.doc).filter((e=>{const n=e.mark.type.excluded;return n.find((n=>n===t.type&&n!==e.mark.type))})).filter((t=>t.to>c));if(d.length)return null;l<n.to&&r.delete(l,n.to);c>n.from&&r.delete(n.from+o,c);const u=n.from+o+i.length;r.addMark(n.from+o,u,t.type.create(s||{}));r.removeStoredMark(t.type)}}})}function nodeInputRule(t){return new InputRule({find:t.find,handler:({state:e,range:n,match:o})=>{const s=callOrReturn(t.getAttributes,void 0,o)||{};const{tr:r}=e;const i=n.from;let a=n.to;const c=t.type.create(s);if(o[1]){const t=o[0].lastIndexOf(o[1]);let e=i+t;e>a?e=a:a=e+o[1].length;const n=o[0][o[0].length-1];r.insertText(n,i+o[0].length-1);r.replaceWith(e,a,c)}else if(o[0]){const e=t.type.isInline?i:i-1;r.insert(e,t.type.create(s)).delete(r.mapping.map(i),r.mapping.map(a))}r.scrollIntoView()}})}function textblockTypeInputRule(t){return new InputRule({find:t.find,handler:({state:e,range:n,match:o})=>{const s=e.doc.resolve(n.from);const r=callOrReturn(t.getAttributes,void 0,o)||{};if(!s.node(-1).canReplaceWith(s.index(-1),s.indexAfter(-1),t.type))return null;e.tr.delete(n.from,n.to).setBlockType(n.from,n.from,t.type,r)}})}function textInputRule(t){return new InputRule({find:t.find,handler:({state:e,range:n,match:o})=>{let s=t.replace;let r=n.from;const i=n.to;if(o[1]){const t=o[0].lastIndexOf(o[1]);s+=o[0].slice(t+o[1].length);r+=t;const e=r-i;if(e>0){s=o[0].slice(t-e,t)+s;r=i}}e.tr.insertText(s,r,i)}})}function wrappingInputRule(t){return new InputRule({find:t.find,handler:({state:e,range:n,match:o,chain:s})=>{const r=callOrReturn(t.getAttributes,void 0,o)||{};const i=e.tr.delete(n.from,n.to);const a=i.doc.resolve(n.from);const c=a.blockRange();const l=c&&E(c,t.type,r);if(!l)return null;i.wrap(c,l);if(t.keepMarks&&t.editor){const{selection:n,storedMarks:o}=e;const{splittableMarks:s}=t.editor.extensionManager;const r=o||n.$to.parentOffset&&n.$from.marks();if(r){const t=r.filter((t=>s.includes(t.type.name)));i.ensureMarks(t)}}if(t.keepAttributes){const e=t.type.name==="bulletList"||t.type.name==="orderedList"?"listItem":"taskList";s().updateAttributes(e,r).run()}const d=i.doc.resolve(n.from-1).nodeBefore;d&&d.type===t.type&&k(i.doc,n.from-1)&&(!t.joinPredicate||t.joinPredicate(o,d))&&i.join(n.from-1)}})}class Node{constructor(t={}){this.type="node";this.name="node";this.parent=null;this.child=null;this.config={name:this.name,defaultOptions:{}};this.config={...this.config,...t};this.name=this.config.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);this.options=this.config.defaultOptions;this.config.addOptions&&(this.options=callOrReturn(getExtensionField(this,"addOptions",{name:this.name})));this.storage=callOrReturn(getExtensionField(this,"addStorage",{name:this.name,options:this.options}))||{}}static create(t={}){return new Node(t)}configure(t={}){const e=this.extend({...this.config,addOptions:()=>mergeDeep(this.options,t)});e.name=this.name;e.parent=this.parent;return e}extend(t={}){const e=new Node(t);e.parent=this;this.child=e;e.name=t.name?t.name:e.parent.name;t.defaultOptions&&Object.keys(t.defaultOptions).length>0&&console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${e.name}".`);e.options=callOrReturn(getExtensionField(e,"addOptions",{name:e.name}));e.storage=callOrReturn(getExtensionField(e,"addStorage",{name:e.name,options:e.options}));return e}}class NodeView{constructor(t,e,n){this.isDragging=false;this.component=t;this.editor=e.editor;this.options={stopEvent:null,ignoreMutation:null,...n};this.extension=e.extension;this.node=e.node;this.decorations=e.decorations;this.innerDecorations=e.innerDecorations;this.view=e.view;this.HTMLAttributes=e.HTMLAttributes;this.getPos=e.getPos;this.mount()}mount(){}get dom(){return this.editor.view.dom}get contentDOM(){return null}onDragStart(t){var e,n,o,s,i,a,c;const{view:l}=this.editor;const d=t.target;const u=d.nodeType===3?(e=d.parentElement)===null||e===void 0?void 0:e.closest("[data-drag-handle]"):d.closest("[data-drag-handle]");if(!this.dom||((n=this.contentDOM)===null||n===void 0?void 0:n.contains(d))||!u)return;let p=0;let m=0;if(this.dom!==u){const e=this.dom.getBoundingClientRect();const n=u.getBoundingClientRect();const r=(o=t.offsetX)!==null&&o!==void 0?o:(s=t.nativeEvent)===null||s===void 0?void 0:s.offsetX;const c=(i=t.offsetY)!==null&&i!==void 0?i:(a=t.nativeEvent)===null||a===void 0?void 0:a.offsetY;p=n.x-e.x+r;m=n.y-e.y+c}const h=this.dom.cloneNode(true);(c=t.dataTransfer)===null||c===void 0?void 0:c.setDragImage(h,p,m);const f=this.getPos();if(typeof f!=="number")return;const g=r.create(l.state.doc,f);const y=l.state.tr.setSelection(g);l.dispatch(y)}stopEvent(t){var e;if(!this.dom)return false;if(typeof this.options.stopEvent==="function")return this.options.stopEvent({event:t});const n=t.target;const o=this.dom.contains(n)&&!((e=this.contentDOM)===null||e===void 0?void 0:e.contains(n));if(!o)return false;const s=t.type.startsWith("drag");const i=t.type==="drop";const a=["INPUT","BUTTON","SELECT","TEXTAREA"].includes(n.tagName)||n.isContentEditable;if(a&&!i&&!s)return true;const{isEditable:c}=this.editor;const{isDragging:l}=this;const d=!!this.node.type.spec.draggable;const u=r.isSelectable(this.node);const p=t.type==="copy";const m=t.type==="paste";const h=t.type==="cut";const f=t.type==="mousedown";!d&&u&&s&&t.target===this.dom&&t.preventDefault();if(d&&s&&!l&&t.target===this.dom){t.preventDefault();return false}if(d&&c&&!l&&f){const t=n.closest("[data-drag-handle]");const e=t&&(this.dom===t||this.dom.contains(t));if(e){this.isDragging=true;document.addEventListener("dragend",(()=>{this.isDragging=false}),{once:true});document.addEventListener("drop",(()=>{this.isDragging=false}),{once:true});document.addEventListener("mouseup",(()=>{this.isDragging=false}),{once:true})}}return!(l||i||p||m||h||f&&u)}ignoreMutation(t){if(!this.dom||!this.contentDOM)return true;if(typeof this.options.ignoreMutation==="function")return this.options.ignoreMutation({mutation:t});if(this.node.isLeaf||this.node.isAtom)return true;if(t.type==="selection")return false;if(this.dom.contains(t.target)&&t.type==="childList"&&(isiOS()||isAndroid())&&this.editor.isFocused){const e=[...Array.from(t.addedNodes),...Array.from(t.removedNodes)];if(e.every((t=>t.isContentEditable)))return false}return this.contentDOM===t.target&&t.type==="attributes"||!this.contentDOM.contains(t.target)}updateAttributes(t){this.editor.commands.command((({tr:e})=>{const n=this.getPos();if(typeof n!=="number")return false;e.setNodeMarkup(n,void 0,{...this.node.attrs,...t});return true}))}deleteNode(){const t=this.getPos();if(typeof t!=="number")return;const e=t+this.node.nodeSize;this.editor.commands.deleteRange({from:t,to:e})}}function markPasteRule(t){return new PasteRule({find:t.find,handler:({state:e,range:n,match:o,pasteEvent:s})=>{const r=callOrReturn(t.getAttributes,void 0,o,s);if(r===false||r===null)return null;const{tr:i}=e;const a=o[o.length-1];const c=o[0];let l=n.to;if(a){const o=c.search(/\S/);const s=n.from+c.indexOf(a);const d=s+a.length;const u=getMarksBetween(n.from,n.to,e.doc).filter((e=>{const n=e.mark.type.excluded;return n.find((n=>n===t.type&&n!==e.mark.type))})).filter((t=>t.to>s));if(u.length)return null;d<n.to&&i.delete(d,n.to);s>n.from&&i.delete(n.from+o,s);l=n.from+o+a.length;i.addMark(n.from+o,l,t.type.create(r||{}));i.removeStoredMark(t.type)}}})}function escapeForRegEx(t){return t.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function isString(t){return typeof t==="string"}function nodePasteRule(t){return new PasteRule({find:t.find,handler({match:e,chain:n,range:o,pasteEvent:s}){const r=callOrReturn(t.getAttributes,void 0,e,s);const i=callOrReturn(t.getContent,void 0,r);if(r===false||r===null)return null;const a={type:t.type.name,attrs:r};i&&(a.content=i);e.input&&n().deleteRange(o).insertContentAt(o.from,a)}})}function textPasteRule(t){return new PasteRule({find:t.find,handler:({state:e,range:n,match:o})=>{let s=t.replace;let r=n.from;const i=n.to;if(o[1]){const t=o[0].lastIndexOf(o[1]);s+=o[0].slice(t+o[1].length);r+=t;const e=r-i;if(e>0){s=o[0].slice(t-e,t)+s;r=i}}e.tr.insertText(s,r,i)}})}class Tracker{constructor(t){this.transaction=t;this.currentStep=this.transaction.steps.length}map(t){let e=false;const n=this.transaction.steps.slice(this.currentStep).reduce(((t,n)=>{const o=n.getMap().mapResult(t);o.deleted&&(e=true);return o.pos}),t);return{position:n,deleted:e}}}export{CommandManager,Editor,Extension,InputRule,Mark,Node,NodePos,NodeView,PasteRule,Tracker,callOrReturn,combineTransactionSteps,createChainableState,createDocument,createNodeFromContent,createStyleTag,defaultBlockAt,deleteProps,elementFromString,escapeForRegEx,nt as extensions,findChildren,findChildrenInRange,findDuplicates,findParentNode,findParentNodeClosestToPos,fromString,generateHTML,generateJSON,generateText,getAttributes,getAttributesFromExtensions,getChangedRanges,getDebugJSON,getExtensionField,getHTMLFromFragment,getMarkAttributes,getMarkRange,getMarkType,getMarksBetween,getNodeAtPosition,getNodeAttributes,getNodeType,getRenderedAttributes,getSchema,getSchemaByResolvedExtensions,getSchemaTypeByName,getSchemaTypeNameByName,getSplittedAttributes,getText,getTextBetween,getTextContentFromNodes,getTextSerializersFromSchema,injectExtensionAttributesToParseRule,inputRulesPlugin,isActive,isAtEndOfNode,isAtStartOfNode,isEmptyObject,isExtensionRulesEnabled,isFunction,isList,isMacOS,isMarkActive,isNodeActive,isNodeEmpty,isNodeSelection,isNumber,isPlainObject,isRegExp,isString,isTextSelection,isiOS,markInputRule,markPasteRule,mergeAttributes,mergeDeep,minMax,nodeInputRule,nodePasteRule,objectIncludes,pasteRulesPlugin,posToDOMRect,removeDuplicates,resolveFocusPosition,rewriteUnknownContent,selectionToInsertionEnd,splitExtensions,textInputRule,textPasteRule,textblockTypeInputRule,wrappingInputRule};

